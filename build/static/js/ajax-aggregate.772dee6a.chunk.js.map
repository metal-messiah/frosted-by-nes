{"version":3,"file":"static/js/ajax-aggregate.772dee6a.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/deny-list/deny-list.js","../node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js","../node_modules/@newrelic/browser-agent/dist/esm/features/ajax/aggregate/gql.js","../node_modules/@newrelic/browser-agent/dist/esm/common/util/type-check.js","../node_modules/@newrelic/browser-agent/dist/esm/features/ajax/aggregate/index.js"],"sourcesContent":["/** An array of filter objects {hostname, pathname} for identifying XHR events to be excluded from collection.\n * @see {@link https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/filter-ajax-request-events/ Filter AjaxRequest events}\n * @type {Array.<{hostname: string, pathname: string}>}\n */\nvar denyList = [];\n\n/**\n * Evaluates whether an XHR event should be included for collection based on the {@link denyList|AjaxRequest deny list}.\n * @param {Object} params - object with properties of the XHR event\n * @returns {boolean} `true` if request does not match any entries of {@link denyList|deny list}; else `false`\n */\nexport function shouldCollectEvent(params) {\n  if (denyList.length === 0) {\n    return true;\n  }\n\n  // XHR requests with an undefined hostname (e.g., data URLs) should not be collected.\n  if (params.hostname === undefined) {\n    return false;\n  }\n  for (var i = 0; i < denyList.length; i++) {\n    var parsed = denyList[i];\n    if (parsed.hostname === '*') {\n      return false;\n    }\n    if (domainMatchesPattern(parsed.hostname, params.hostname) && comparePath(parsed.pathname, params.pathname)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Initializes the {@link denyList|XHR deny list} by extracting hostname and pathname from an array of filter strings.\n * @param {string[]} denyListConfig - array of URL filters to identify XHR requests to be excluded from collection\n */\nexport function setDenyList(denyListConfig) {\n  denyList = [];\n  if (!denyListConfig || !denyListConfig.length) {\n    return;\n  }\n  for (var i = 0; i < denyListConfig.length; i++) {\n    let url = denyListConfig[i];\n    if (!url) continue; // ignore bad values like undefined or empty strings\n\n    if (url.indexOf('http://') === 0) {\n      url = url.substring(7);\n    } else if (url.indexOf('https://') === 0) {\n      url = url.substring(8);\n    }\n    const firstSlash = url.indexOf('/');\n    let host, pathname;\n    if (firstSlash > 0) {\n      host = url.substring(0, firstSlash);\n      pathname = url.substring(firstSlash);\n    } else {\n      host = url;\n      pathname = '';\n    }\n    let [hostname] = host.split(':');\n    denyList.push({\n      hostname,\n      pathname\n    });\n  }\n}\n/**\n * Returns true if the right side of `domain` (end of string) matches `pattern`.\n * @param {string} pattern - a string to be matched against the end of `domain` string\n * @param {string} domain - a domain string with no protocol or path (e.g., app1.example.com)\n * @returns {boolean} `true` if domain matches pattern; else `false`\n */\nfunction domainMatchesPattern(pattern, domain) {\n  if (pattern.length > domain.length) {\n    return false;\n  }\n  return domain.indexOf(pattern) === domain.length - pattern.length;\n}\n\n/**\n * Returns true if a URL path matches a pattern string, disregarding leading slashes.\n * @param {string} pattern - a string to compare with path (e.g., api/v1)\n * @param {string} path - a string representing a URL path (e.g., /api/v1)\n * @returns {boolean} `true` if path and pattern are an exact string match (except for leading slashes); else `false`\n */\nfunction comparePath(pattern, path) {\n  if (pattern.indexOf('/') === 0) {\n    pattern = pattern.substring(1);\n  }\n  if (path.indexOf('/') === 0) {\n    path = path.substring(1);\n  }\n\n  // No path in pattern means match all paths.\n  if (pattern === '') {\n    return true;\n  }\n  return pattern === path;\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mapOwn } from '../util/map-own';\nimport { stringify } from '../util/stringify';\nimport { Obfuscator } from '../util/obfuscate';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(agentIdentifier) {\n  // eslint-disable-next-line\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {};\n  var stringTableIdx = 0;\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    var obfuscator = new Obfuscator({\n      agentIdentifier\n    });\n    str = String(str);\n    if (obfuscator.shouldObfuscate()) str = obfuscator.obfuscateString(str);\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}","import { isPureObject } from '../../../common/util/type-check';\n\n/**\n * @typedef {object} GQLMetadata\n * @property {string} operationName Name of the operation\n * @property {string} operationType Type of the operation\n * @property {string} operationFramework Framework responsible for the operation\n */\n\n/**\n * Parses and returns the graphql metadata from a network request. If the network\n * request is not a graphql call, undefined will be returned.\n * @param {object|string} body Ajax request body\n * @param {string} query Ajax request query param string\n * @returns {GQLMetadata | undefined}\n */\nexport function parseGQL() {\n  let {\n    body,\n    query\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!body && !query) return;\n  try {\n    const gqlBody = parseBatchGQL(parseGQLContents(body));\n    if (gqlBody) return gqlBody;\n    const gqlQuery = parseSingleGQL(parseGQLQueryString(query));\n    if (gqlQuery) return gqlQuery;\n  } catch (err) {\n    // parsing failed, return undefined\n  }\n}\n\n/**\n * @param {string|Object} gql The GraphQL object body sent to a GQL server\n * @returns {GQLMetadata}\n */\nfunction parseSingleGQL(contents) {\n  if (typeof contents !== 'object' || !contents.query || typeof contents.query !== 'string') return;\n\n  /** parses gql query string and returns [fullmatch, type match, name match] */\n  const matches = contents.query.trim().match(/^(query|mutation|subscription)\\s?(\\w*)/);\n  const operationType = matches?.[1];\n  if (!operationType) return;\n  const operationName = contents.operationName || matches?.[2] || 'Anonymous';\n  return {\n    operationName,\n    // the operation name of the indiv query\n    operationType,\n    // query, mutation, or subscription,\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseBatchGQL(contents) {\n  if (!contents) return;\n  if (!Array.isArray(contents)) contents = [contents];\n  const opNames = [];\n  const opTypes = [];\n  for (let content of contents) {\n    const operation = parseSingleGQL(content);\n    if (!operation) continue;\n    opNames.push(operation.operationName);\n    opTypes.push(operation.operationType);\n  }\n  if (!opTypes.length) return;\n  return {\n    operationName: opNames.join(','),\n    // the operation name of the indiv query -- joined by ',' for batched results\n    operationType: opTypes.join(','),\n    // query, mutation, or subscription -- joined by ',' for batched results\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseGQLContents(gqlContents) {\n  let contents;\n  if (!gqlContents || typeof gqlContents !== 'string' && typeof gqlContents !== 'object') return;else if (typeof gqlContents === 'string') contents = JSON.parse(gqlContents);else contents = gqlContents;\n  if (!isPureObject(contents) && !Array.isArray(contents)) return;\n  let isValid = false;\n  if (Array.isArray(contents)) isValid = contents.some(x => validateGQLObject(x));else isValid = validateGQLObject(contents);\n  if (!isValid) return;\n  return contents;\n}\nfunction parseGQLQueryString(gqlQueryString) {\n  if (!gqlQueryString || typeof gqlQueryString !== 'string') return;\n  const params = new URLSearchParams(gqlQueryString);\n  return parseGQLContents(Object.fromEntries(params));\n}\nfunction validateGQLObject(obj) {\n  return !(typeof obj !== 'object' || !obj.query || typeof obj.query !== 'string');\n}","/**\n * Tests a passed object to see if it is a pure object or not. All non-primatives in JS\n * are technically objects and would pass a `typeof` check.\n * @param {*} obj Input object to be tested\n**/\nexport function isPureObject(obj) {\n  return obj?.constructor === {}.constructor;\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { stringify } from '../../../common/util/stringify';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { getConfiguration, getInfo, getRuntime } from '../../../common/config/config';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { setDenyList, shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { FEATURE_NAME } from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { parseGQL } from './gql';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    const agentInit = getConfiguration(agentIdentifier);\n    const allAjaxIsEnabled = agentInit.ajax.enabled !== false;\n    register('xhr', storeXhr, this.featureName, this.ee);\n    if (!allAjaxIsEnabled) {\n      this.drain();\n      return; // feature will only collect timeslice metrics & ajax trace nodes if it's not fully enabled\n    }\n\n    const denyList = getRuntime(agentIdentifier).denyList;\n    setDenyList(denyList);\n    let ajaxEvents = [];\n    let spaAjaxEvents = {};\n    let sentAjaxEvents = [];\n    const ee = this.ee;\n    const harvestTimeSeconds = agentInit.ajax.harvestTimeSeconds || 10;\n    const MAX_PAYLOAD_SIZE = agentInit.ajax.maxPayloadSize || 1000000;\n\n    // Exposes these methods to browser test files -- future TO DO: can be removed once these fns are extracted from the constructor into class func\n    this.storeXhr = storeXhr;\n    this.prepareHarvest = prepareHarvest;\n    this.getStoredEvents = function () {\n      return {\n        ajaxEvents,\n        spaAjaxEvents\n      };\n    };\n    ee.on('interactionSaved', interaction => {\n      if (!spaAjaxEvents[interaction.id]) return;\n      // remove from the spaAjaxEvents buffer, and let spa harvest it\n      delete spaAjaxEvents[interaction.id];\n    });\n    ee.on('interactionDiscarded', interaction => {\n      if (!spaAjaxEvents[interaction.id]) return;\n      spaAjaxEvents[interaction.id].forEach(function (item) {\n        // move it from the spaAjaxEvents buffer to the ajaxEvents buffer for harvesting here\n        ajaxEvents.push(item);\n      });\n      delete spaAjaxEvents[interaction.id];\n    });\n    const scheduler = new HarvestScheduler('events', {\n      onFinished: onEventsHarvestFinished,\n      getPayload: prepareHarvest\n    }, this);\n    ee.on(\"drain-\".concat(this.featureName), () => {\n      scheduler.startTimer(harvestTimeSeconds);\n    });\n    this.drain();\n    const beacon = getInfo(agentIdentifier).errorBeacon;\n    const proxyBeacon = agentInit.proxy.beacon;\n    function storeXhr(params, metrics, startTime, endTime, type) {\n      metrics.time = startTime;\n\n      // send to session traces\n      var hash;\n      if (params.cat) {\n        hash = stringify([params.status, params.cat]);\n      } else {\n        hash = stringify([params.status, params.host, params.pathname]);\n      }\n\n      // store as metric\n      aggregator.store('xhr', hash, params, metrics);\n      if (!allAjaxIsEnabled) return;\n      if (!shouldCollectEvent(params)) {\n        if (params.hostname === beacon || proxyBeacon && params.hostname === proxyBeacon) {\n          // This doesn't make a distinction if the same-domain request is going to a different port or path...\n          handle(SUPPORTABILITY_METRIC_CHANNEL, ['Ajax/Events/Excluded/Agent'], undefined, FEATURE_NAMES.metrics, ee);\n        } else {\n          handle(SUPPORTABILITY_METRIC_CHANNEL, ['Ajax/Events/Excluded/App'], undefined, FEATURE_NAMES.metrics, ee);\n        }\n        return;\n      }\n      handle('bstXhrAgg', ['xhr', hash, params, metrics], undefined, FEATURE_NAMES.sessionTrace, ee);\n      var xhrContext = this;\n      var event = {\n        method: params.method,\n        status: params.status,\n        domain: params.host,\n        path: params.pathname,\n        requestSize: metrics.txSize,\n        responseSize: metrics.rxSize,\n        type,\n        startTime,\n        endTime,\n        callbackDuration: metrics.cbTime\n      };\n      if (xhrContext.dt) {\n        event.spanId = xhrContext.dt.spanId;\n        event.traceId = xhrContext.dt.traceId;\n        event.spanTimestamp = xhrContext.dt.timestamp;\n      }\n\n      // parsed from the AJAX body, looking for operationName param & parsing query for operationType\n      event.gql = params.gql = parseGQL({\n        body: this.body,\n        query: this?.parsedOrigin?.search\n      });\n      if (event.gql) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Ajax/Events/GraphQL/Bytes-Added', stringify(event.gql).length], undefined, FEATURE_NAMES.metrics, ee);\n\n      // if the ajax happened inside an interaction, hold it until the interaction finishes\n      if (this.spaNode) {\n        var interactionId = this.spaNode.interaction.id;\n        spaAjaxEvents[interactionId] = spaAjaxEvents[interactionId] || [];\n        spaAjaxEvents[interactionId].push(event);\n      } else {\n        ajaxEvents.push(event);\n      }\n    }\n    function prepareHarvest(options) {\n      options = options || {};\n      if (ajaxEvents.length === 0) {\n        return null;\n      }\n      var payload = getPayload(ajaxEvents, options.maxPayloadSize || MAX_PAYLOAD_SIZE);\n      var payloadObjs = [];\n      for (var i = 0; i < payload.length; i++) {\n        payloadObjs.push({\n          body: {\n            e: payload[i]\n          }\n        });\n      }\n      if (options.retry) {\n        sentAjaxEvents = ajaxEvents.slice();\n      }\n      ajaxEvents = [];\n      return payloadObjs;\n    }\n    function getPayload(events, maxPayloadSize, chunks) {\n      chunks = chunks || 1;\n      var payload = [];\n      var chunkSize = events.length / chunks;\n      var eventChunks = splitChunks(events, chunkSize);\n      var tooBig = false;\n      for (var i = 0; i < eventChunks.length; i++) {\n        var currentChunk = eventChunks[i];\n        if (currentChunk.tooBig(maxPayloadSize)) {\n          if (currentChunk.events.length !== 1) {\n            /* if it is too big BUT it isnt length 1, we can split it down again,\n             else we just want to NOT push it into payload\n             because if it's length 1 and still too big for the maxPayloadSize\n             it cant get any smaller and we dont want to recurse forever */\n            tooBig = true;\n            break;\n          }\n        } else {\n          payload.push(currentChunk.payload);\n        }\n      }\n      // check if the current payload string is too big, if so then run getPayload again with more buckets\n      return tooBig ? getPayload(events, maxPayloadSize, ++chunks) : payload;\n    }\n    function onEventsHarvestFinished(result) {\n      if (result.retry && sentAjaxEvents.length > 0) {\n        ajaxEvents.unshift(...sentAjaxEvents);\n        sentAjaxEvents = [];\n      }\n    }\n    function splitChunks(arr, chunkSize) {\n      chunkSize = chunkSize || arr.length;\n      var chunks = [];\n      for (var i = 0, len = arr.length; i < len; i += chunkSize) {\n        chunks.push(new Chunk(arr.slice(i, i + chunkSize)));\n      }\n      return chunks;\n    }\n    function Chunk(events) {\n      this.addString = getAddStringContext(agentIdentifier); // pass agentIdentifier here\n      this.events = events;\n      this.payload = 'bel.7;';\n      for (var i = 0; i < events.length; i++) {\n        var event = events[i];\n        var fields = [numeric(event.startTime), numeric(event.endTime - event.startTime), numeric(0),\n        // callbackEnd\n        numeric(0),\n        // no callbackDuration for non-SPA events\n        this.addString(event.method), numeric(event.status), this.addString(event.domain), this.addString(event.path), numeric(event.requestSize), numeric(event.responseSize), event.type === 'fetch' ? 1 : '', this.addString(0),\n        // nodeId\n        nullable(event.spanId, this.addString, true) +\n        // guid\n        nullable(event.traceId, this.addString, true) +\n        // traceId\n        nullable(event.spanTimestamp, numeric, false) // timestamp\n        ];\n\n        var insert = '2,';\n\n        // add custom attributes\n        // gql decorators are added as custom attributes to alleviate need for new BEL schema\n        var attrParts = addCustomAttributes({\n          ...(getInfo(agentIdentifier).jsAttributes || {}),\n          ...(event.gql || {})\n        }, this.addString);\n        fields.unshift(numeric(attrParts.length));\n        insert += fields.join(',');\n        if (attrParts && attrParts.length > 0) {\n          insert += ';' + attrParts.join(';');\n        }\n        if (i + 1 < events.length) insert += ';';\n        this.payload += insert;\n      }\n      this.tooBig = function (maxPayloadSize) {\n        maxPayloadSize = maxPayloadSize || MAX_PAYLOAD_SIZE;\n        return this.payload.length * 2 > maxPayloadSize;\n      };\n    }\n  }\n}"],"names":["denyList","shouldCollectEvent","params","length","undefined","hostname","i","parsed","domainMatchesPattern","comparePath","pathname","setDenyList","denyListConfig","url","indexOf","substring","firstSlash","host","split","push","pattern","domain","path","hasOwnProp","Object","prototype","hasOwnProperty","MAX_ATTRIBUTES","nullable","val","fn","comma","numeric","n","noDefault","Math","floor","toString","getAddStringContext","agentIdentifier","stringTable","create","stringTableIdx","str","obfuscator","Obfuscator","String","shouldObfuscate","obfuscateString","call","replace","escapable","quoteString","addCustomAttributes","attrs","addString","attrParts","mapOwn","key","serializedValue","type","stringify","parseGQL","body","query","arguments","gqlBody","contents","Array","isArray","opNames","opTypes","content","operation","parseSingleGQL","operationName","operationType","join","operationFramework","parseBatchGQL","parseGQLContents","gqlQuery","gqlQueryString","URLSearchParams","fromEntries","parseGQLQueryString","err","matches","trim","match","gqlContents","JSON","parse","obj","constructor","isValid","some","x","validateGQLObject","Aggregate","AggregateBase","aggregator","super","FEATURE_NAME","agentInit","getConfiguration","allAjaxIsEnabled","ajax","enabled","register","storeXhr","this","featureName","ee","drain","getRuntime","ajaxEvents","spaAjaxEvents","sentAjaxEvents","harvestTimeSeconds","MAX_PAYLOAD_SIZE","maxPayloadSize","prepareHarvest","getStoredEvents","on","interaction","id","forEach","item","scheduler","HarvestScheduler","onFinished","result","retry","unshift","getPayload","concat","startTimer","beacon","getInfo","errorBeacon","proxyBeacon","proxy","metrics","startTime","endTime","_this$parsedOrigin","hash","time","cat","status","store","handle","FEATURE_NAMES","sessionTrace","xhrContext","event","method","requestSize","txSize","responseSize","rxSize","callbackDuration","cbTime","dt","spanId","traceId","spanTimestamp","timestamp","gql","parsedOrigin","search","SUPPORTABILITY_METRIC_CHANNEL","spaNode","interactionId","options","payload","payloadObjs","e","slice","events","chunks","eventChunks","arr","chunkSize","len","Chunk","splitChunks","tooBig","currentChunk","fields","insert","jsAttributes","_defineProperty"],"sourceRoot":""}