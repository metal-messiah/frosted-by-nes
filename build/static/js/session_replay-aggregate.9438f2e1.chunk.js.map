{"version":3,"file":"static/js/session_replay-aggregate.9438f2e1.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2023 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n *\n * NOTE: This code is under development and dormant. It will not download to instrumented pages or record any data.\n * It is not production ready, and is not intended to be imported or implemented in any build of the browser agent until\n * functionality is validated and a full user experience is curated.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { FEATURE_NAME } from '../constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { getConfigurationValue, getInfo, getRuntime } from '../../../common/config/config';\nimport { SESSION_EVENTS, MODE, SESSION_EVENT_TYPES } from '../../../common/session/session-entity';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nimport { now } from '../../../common/timing/now';\nexport const AVG_COMPRESSION = 0.12;\nexport const RRWEB_EVENT_TYPES = {\n  DomContentLoaded: 0,\n  Load: 1,\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Custom: 5\n};\nconst ABORT_REASONS = {\n  RESET: {\n    message: 'Session was reset',\n    sm: 'Reset'\n  },\n  IMPORT: {\n    message: 'Recorder failed to import',\n    sm: 'Import'\n  },\n  TOO_MANY: {\n    message: '429: Too Many Requests',\n    sm: 'Too-Many'\n  },\n  TOO_BIG: {\n    message: 'Payload was too large',\n    sm: 'Too-Big'\n  },\n  CROSS_TAB: {\n    message: 'Session Entity was set to OFF on another tab',\n    sm: 'Cross-Tab'\n  }\n};\nlet recorder, gzipper, u8;\n\n/** Vortex caps payload sizes at 1MB */\nexport const MAX_PAYLOAD_SIZE = 1000000;\n/** Unloading caps around 64kb */\nexport const IDEAL_PAYLOAD_SIZE = 64000;\n/** Reserved room for query param attrs */\nconst QUERY_PARAM_PADDING = 5000;\n/** Interval between forcing new full snapshots -- 15 seconds in error mode (x2), 5 minutes in full mode */\nconst CHECKOUT_MS = {\n  [MODE.ERROR]: 15000,\n  [MODE.FULL]: 300000,\n  [MODE.OFF]: 0\n};\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    /** Each page mutation or event will be stored (raw) in this array. This array will be cleared on each harvest */\n    this.events = [];\n    /** Backlog used for a 2-part sliding window to guarantee a 15-30s buffer window */\n    this.backloggedEvents = [];\n    /** The interval to harvest at.  This gets overridden if the size of the payload exceeds certain thresholds */\n    this.harvestTimeSeconds = getConfigurationValue(this.agentIdentifier, 'session_replay.harvestTimeSeconds') || 60;\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once an error has been detected on the page. Never unset */\n    this.errorNoticed = false;\n    /** The \"mode\" to record in.  Defaults to \"OFF\" until flags and sampling are checked. See \"MODE\" constant. */\n    this.mode = MODE.OFF;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** True when actively recording, false when paused or stopped */\n    this.recording = false;\n    /** can shut off efforts to compress the data */\n    this.shouldCompress = true;\n\n    /** Payload metadata -- Should indicate that the payload being sent has a full DOM snapshot. This can happen\n     * -- When the recording library begins recording, it starts by taking a DOM snapshot\n     * -- When visibility changes from \"hidden\" -> \"visible\", it must capture a full snapshot for the replay to work correctly across tabs\n    */\n    this.hasSnapshot = false;\n    /** Payload metadata -- Should indicate that the payload being sent has a meta node. The meta node should always precede a snapshot node. */\n    this.hasMeta = false;\n    /** Payload metadata -- Should indicate that the payload being sent contains an error.  Used for query/filter purposes in UI */\n    this.hasError = false;\n\n    /** Payload metadata -- Should indicate when a replay blob started recording.  Resets each time a harvest occurs.\n     * cycle timestamps are used as fallbacks if event timestamps cannot be used\n     */\n    this.cycleTimestamp = undefined;\n\n    /** A value which increments with every new mutation node reported. Resets after a harvest is sent */\n    this.payloadBytesEstimation = 0;\n\n    /** Hold on to the last meta node, so that it can be re-inserted if the meta and snapshot nodes are broken up due to harvesting */\n    this.lastMeta = undefined;\n\n    /** set by BCS response */\n    this.entitled = false;\n    const shouldSetup = getConfigurationValue(agentIdentifier, 'privacy.cookies_enabled') === true && getConfigurationValue(agentIdentifier, 'session_trace.enabled') === true;\n\n    /** The method to stop recording. This defaults to a noop, but is overwritten once the recording library is imported and initialized */\n    this.stopRecording = () => {/* no-op until set by rrweb initializer */};\n    if (shouldSetup) {\n      // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n      this.ee.on(SESSION_EVENTS.RESET, () => {\n        this.abort(ABORT_REASONS.RESET);\n      });\n\n      // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n      this.ee.on(SESSION_EVENTS.PAUSE, () => {\n        this.stopRecording();\n      });\n      // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n      this.ee.on(SESSION_EVENTS.RESUME, () => {\n        // if the mode changed on a different tab, it needs to update this instance to match\n        const {\n          session\n        } = getRuntime(this.agentIdentifier);\n        this.mode = session.state.sessionReplayMode;\n        if (!this.initialized || this.mode === MODE.OFF) return;\n        this.startRecording();\n      });\n      this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n        if (!this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n        if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n        this.mode = data.sessionReplay;\n      });\n\n      // Bespoke logic for new endpoint.  This will change as downstream dependencies become solidified.\n      this.scheduler = new HarvestScheduler('browser/blobs', {\n        onFinished: this.onHarvestFinished.bind(this),\n        retryDelay: this.harvestTimeSeconds,\n        getPayload: this.prepareHarvest.bind(this),\n        raw: true\n      }, this);\n      registerHandler('recordReplay', () => {\n        // if it has aborted or BCS returned bad entitlements, do not allow\n        if (this.blocked || !this.entitled) return;\n        // if it isnt already (fully) initialized... initialize it\n        if (!recorder) this.initializeRecording(false, true, true);\n        // its been initialized and imported the recorder but its not recording (mode === off || error)\n        else if (this.mode !== MODE.FULL) this.switchToFull();\n        // if it gets all the way to here, that means a full session is already recording... do nothing\n      }, this.featureName, this.ee);\n      registerHandler('pauseReplay', () => {\n        this.forceStop(this.mode !== MODE.ERROR);\n      }, this.featureName, this.ee);\n\n      // Wait for an error to be reported.  This currently is wrapped around the \"Error\" feature.  This is a feature-feature dependency.\n      // This was to ensure that all errors, including those on the page before load and those handled with \"noticeError\" are accounted for. Needs evalulation\n      registerHandler('errorAgg', e => {\n        this.hasError = true;\n        this.errorNoticed = true;\n        // run once\n        if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n          this.switchToFull();\n        }\n      }, this.featureName, this.ee);\n      this.waitForFlags(['sr']).then(_ref => {\n        let [flagOn] = _ref;\n        this.entitled = flagOn;\n        this.initializeRecording(Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.error_sampling_rate'), Math.random() * 100 < getConfigurationValue(this.agentIdentifier, 'session_replay.sampling_rate'));\n      }).then(() => sharedChannel.onReplayReady(this.mode)); // notify watchers that replay started with the mode\n\n      this.drain();\n    }\n  }\n  switchToFull() {\n    this.mode = MODE.FULL;\n    // if the error was noticed AFTER the recorder was already imported....\n    if (recorder && this.initialized) {\n      this.stopRecording();\n      this.startRecording();\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n      this.syncWithSessionManager({\n        sessionReplayMode: this.mode\n      });\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} entitlements - the true/false state of the \"sr\" flag from RUM response\n   * @param {boolean} errorSample - the true/false state of the error sampling decision\n   * @param {boolean} fullSample - the true/false state of the full sampling decision\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */\n  async initializeRecording(errorSample, fullSample, ignoreSession) {\n    this.initialized = true;\n    if (!this.entitled || this.recording) return;\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    if (!session.isNew && !ignoreSession) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      if (fullSample) this.mode = MODE.FULL; // full mode has precedence over error mode\n      else if (errorSample) this.mode = MODE.ERROR;\n      // If neither are selected, then don't record (early return)\n      else return;\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) {\n      this.mode = MODE.FULL;\n    }\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      recorder = (await import( /* webpackChunkName: \"recorder\" */'rrweb')).record;\n    } catch (err) {\n      return this.abort(ABORT_REASONS.IMPORT);\n    }\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // If an error happened in ERROR mode before we've gotten to this stage, it will have already set the mode to FULL\n    if (this.mode === MODE.FULL) {\n      // We only report (harvest) in FULL mode\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import( /* webpackChunkName: \"compressor\" */'fflate');\n      gzipper = gzipSync;\n      u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n      this.shouldCompress = false;\n    }\n    this.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  prepareHarvest() {\n    if (this.events.length === 0 || this.mode !== MODE.FULL && !this.blocked) return;\n    const payload = this.getHarvestContents();\n    if (!payload.body.length) {\n      this.clearBuffer();\n      return;\n    }\n    if (this.shouldCompress) {\n      payload.body = gzipper(u8(stringify(payload.body)));\n      this.scheduler.opts.gzip = true;\n    } else {\n      this.scheduler.opts.gzip = false;\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    if (!session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.clearBuffer();\n    return [payload];\n  }\n  getHarvestContents() {\n    const agentRuntime = getRuntime(this.agentIdentifier);\n    const info = getInfo(this.agentIdentifier);\n    const endUserId = info.jsAttributes?.['enduser.id'];\n    if (this.backloggedEvents.length) this.events = [...this.backloggedEvents, ...this.events];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = this.events[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.lastMeta) {\n      this.hasMeta = true;\n      this.events.unshift(this.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = this.events[this.events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.lastMeta = this.events[this.events.length - 1];\n      this.events = this.events.slice(0, this.events.length - 1);\n      this.hasMeta = !!this.events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const agentOffset = getRuntime(this.agentIdentifier).offset;\n    const relativeNow = now();\n    const firstEventTimestamp = this.events[0]?.timestamp; // from rrweb node\n    const lastEventTimestamp = this.events[this.events.length - 1]?.timestamp; // from rrweb node\n    const firstTimestamp = firstEventTimestamp || this.cycleTimestamp;\n    const lastTimestamp = lastEventTimestamp || agentOffset + relativeNow;\n    return {\n      qs: {\n        browser_monitoring_key: info.licenseKey,\n        type: 'SessionReplay',\n        app_id: info.applicationID,\n        protocol_version: '0',\n        attributes: encodeObj({\n          // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n          // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n          ...(this.shouldCompress && {\n            content_encoding: 'gzip'\n          }),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.firstTimestampOffset': firstTimestamp - agentOffset,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.durationMs': lastTimestamp - firstTimestamp,\n          'replay.nodes': this.events.length,\n          'session.durationMs': agentRuntime.session.getDuration(),\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          rst: relativeNow,\n          hasMeta: this.hasMeta,\n          hasSnapshot: this.hasSnapshot,\n          hasError: this.hasError,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: this.payloadBytesEstimation,\n          'rrweb.version': RRWEB_VERSION,\n          // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n          ...(endUserId && {\n            'enduser.id': endUserId\n          })\n          // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n        }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n      },\n\n      body: this.events\n    };\n  }\n  onHarvestFinished(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n    if (this.blocked) this.scheduler.stopTimer(true);\n  }\n\n  /** Clears the buffer (this.events), and resets all payload metadata properties */\n  clearBuffer() {\n    if (this.mode === MODE.ERROR) this.backloggedEvents = this.events;else this.backloggedEvents = [];\n    this.events = [];\n    this.hasSnapshot = false;\n    this.hasMeta = false;\n    this.hasError = false;\n    this.payloadBytesEstimation = 0;\n    this.clearTimestamps();\n  }\n\n  /** Begin recording using configured recording lib */\n  startRecording() {\n    if (!recorder) {\n      warn('Recording library was never imported');\n      return this.abort(ABORT_REASONS.IMPORT);\n    }\n    this.recording = true;\n    const {\n      block_class,\n      ignore_class,\n      mask_text_class,\n      block_selector,\n      mask_input_options,\n      mask_text_selector,\n      mask_all_inputs,\n      inline_images,\n      inline_stylesheet,\n      collect_fonts\n    } = getConfigurationValue(this.agentIdentifier, 'session_replay');\n    // set up rrweb configurations for maximum privacy --\n    // https://newrelic.atlassian.net/wiki/spaces/O11Y/pages/2792293280/2023+02+28+Browser+-+Session+Replay#Configuration-options\n    const stop = recorder({\n      emit: this.store.bind(this),\n      blockClass: block_class,\n      ignoreClass: ignore_class,\n      maskTextClass: mask_text_class,\n      blockSelector: block_selector,\n      maskInputOptions: mask_input_options,\n      maskTextSelector: mask_text_selector,\n      maskAllInputs: mask_all_inputs,\n      inlineImages: inline_images,\n      inlineStylesheet: inline_stylesheet,\n      collectFonts: collect_fonts,\n      checkoutEveryNms: CHECKOUT_MS[this.mode]\n    });\n    this.stopRecording = () => {\n      this.recording = false;\n      stop();\n    };\n  }\n\n  /** Store a payload in the buffer (this.events).  This should be the callback to the recording lib noticing a mutation */\n  store(event, isCheckout) {\n    this.setTimestamps();\n    if (this.blocked) return;\n    const eventBytes = stringify(event).length;\n    /** The estimated size of the payload after compression */\n    const payloadSize = this.getPayloadSize(eventBytes);\n    // Vortex will block payloads at a certain size, we might as well not send.\n    if (payloadSize > MAX_PAYLOAD_SIZE) {\n      this.clearBuffer();\n      return this.abort(ABORT_REASONS.TOO_BIG);\n    }\n    // Checkout events are flags by the recording lib that indicate a fullsnapshot was taken every n ms. These are important\n    // to help reconstruct the replay later and must be included.  While waiting and buffering for errors to come through,\n    // each time we see a new checkout, we can drop the old data.\n    // we need to check for meta because rrweb will flag it as checkout twice, once for meta, then once for snapshot\n    if (this.mode === MODE.ERROR && isCheckout && event.type === RRWEB_EVENT_TYPES.Meta) {\n      // we are still waiting for an error to throw, so keep wiping the buffer over time\n      this.clearBuffer();\n    }\n\n    // meta event\n    if (event.type === RRWEB_EVENT_TYPES.Meta) {\n      this.hasMeta = true;\n    }\n    // snapshot event\n    if (event.type === RRWEB_EVENT_TYPES.FullSnapshot) {\n      this.hasSnapshot = true;\n    }\n    this.events.push(event);\n    this.payloadBytesEstimation += eventBytes;\n\n    // We are making an effort to try to keep payloads manageable for unloading.  If they reach the unload limit before their interval,\n    // it will send immediately.  This often happens on the first snapshot, which can be significantly larger than the other payloads.\n    if (payloadSize > IDEAL_PAYLOAD_SIZE && this.mode !== MODE.ERROR) {\n      // if we've made it to the ideal size of ~64kb before the interval timer, we should send early.\n      this.scheduler.runHarvest();\n    }\n  }\n\n  /** force the recording lib to take a full DOM snapshot.  This needs to occur in certain cases, like visibility changes */\n  takeFullSnapshot() {\n    if (!recorder) return;\n    recorder.takeFullSnapshot();\n  }\n  setTimestamps() {\n    // fallbacks if timestamps cannot be derived from rrweb events\n    if (!this.cycleTimestamp) this.cycleTimestamp = getRuntime(this.agentIdentifier).offset + globalScope.performance.now();\n  }\n  clearTimestamps() {\n    this.cycleTimestamp = undefined;\n  }\n\n  /** Estimate the payload size */\n  getPayloadSize() {\n    let newBytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    // the query param padding constant gives us some padding for the other metadata to be safely injected\n    return this.estimateCompression(this.payloadBytesEstimation + newBytes) + QUERY_PARAM_PADDING;\n  }\n\n  /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */\n  forceStop(forceHarvest) {\n    if (forceHarvest) this.scheduler.runHarvest();\n    this.mode = MODE.OFF;\n    this.stopRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    warn(\"SR aborted -- \".concat(reason.message));\n    handle(SUPPORTABILITY_METRIC_CHANNEL, [\"SessionReplay/Abort/\".concat(reason.sm)], undefined, FEATURE_NAMES.metrics, this.ee);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.stopRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.clearTimestamps();\n    this.ee.emit('REPLAY_ABORTED');\n  }\n\n  /** Extensive research has yielded about an 88% compression factor on these payloads.\n   * This is an estimation using that factor as to not cause performance issues while evaluating\n   * https://staging.onenr.io/037jbJWxbjy\n   * */\n  estimateCompression(data) {\n    if (this.shouldCompress) return data * AVG_COMPRESSION;\n    return data;\n  }\n  syncWithSessionManager() {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    session.write(state);\n  }\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","AVG_COMPRESSION","RRWEB_EVENT_TYPES","DomContentLoaded","Load","FullSnapshot","IncrementalSnapshot","Meta","Custom","ABORT_REASONS","message","sm","recorder","gzipper","u8","MAX_PAYLOAD_SIZE","IDEAL_PAYLOAD_SIZE","CHECKOUT_MS","MODE","ERROR","FULL","OFF","Aggregate","AggregateBase","constructor","agentIdentifier","aggregator","super","FEATURE_NAME","this","events","backloggedEvents","harvestTimeSeconds","getConfigurationValue","initialized","errorNoticed","mode","blocked","recording","shouldCompress","hasSnapshot","hasMeta","hasError","cycleTimestamp","undefined","payloadBytesEstimation","lastMeta","entitled","shouldSetup","stopRecording","ee","on","SESSION_EVENTS","RESET","abort","PAUSE","RESUME","session","getRuntime","state","sessionReplayMode","startRecording","UPDATE","type","data","SESSION_EVENT_TYPES","CROSS_TAB","sessionReplay","scheduler","HarvestScheduler","onFinished","onHarvestFinished","bind","retryDelay","getPayload","prepareHarvest","raw","registerHandler","switchToFull","initializeRecording","featureName","forceStop","e","globalScope","document","visibilityState","waitForFlags","then","_ref","flagOn","Math","random","drain","startTimer","syncWithSessionManager","errorSample","fullSample","ignoreSession","isNew","record","err","gzipSync","strToU8","length","payload","getHarvestContents","body","clearBuffer","stringify","opts","gzip","sessionReplaySentFirstChunk","_info$jsAttributes","_this$events$","_this$events","_this$events$2","_this$events2","agentRuntime","info","getInfo","endUserId","jsAttributes","unshift","slice","find","x","agentOffset","offset","relativeNow","now","firstEventTimestamp","timestamp","lastEventTimestamp","firstTimestamp","lastTimestamp","qs","browser_monitoring_key","licenseKey","app_id","applicationID","protocol_version","attributes","encodeObj","content_encoding","getDuration","agentVersion","version","value","rst","isFirstChunk","decompressedBytes","RRWEB_VERSION","substring","result","status","stopTimer","clearTimestamps","warn","block_class","ignore_class","mask_text_class","block_selector","mask_input_options","mask_text_selector","mask_all_inputs","inline_images","inline_stylesheet","collect_fonts","stop","emit","store","blockClass","ignoreClass","maskTextClass","blockSelector","maskInputOptions","maskTextSelector","maskAllInputs","inlineImages","inlineStylesheet","collectFonts","checkoutEveryNms","event","isCheckout","setTimestamps","eventBytes","payloadSize","getPayloadSize","push","runHarvest","takeFullSnapshot","performance","newBytes","arguments","estimateCompression","forceHarvest","reason","concat","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","metrics","write","_defineProperty"],"sourceRoot":""}