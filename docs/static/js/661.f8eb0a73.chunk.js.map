{"version":3,"file":"static/js/661.f8eb0a73.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/timer/timer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/timer/interaction-timer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/session/session-entity.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/common/util/invoke.js"],"sourcesContent":["/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/session-entity';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","export class Timer {\n  constructor(opts, ms) {\n    if (!opts.onEnd) throw new Error('onEnd handler is required');\n    if (!ms) throw new Error('ms duration is required');\n    this.onEnd = opts.onEnd;\n    this.initialMs = ms;\n    this.startTimestamp = Date.now();\n    this.timer = this.create(this.onEnd, ms);\n  }\n  create(cb, ms) {\n    if (this.timer) this.clear();\n    return setTimeout(() => cb ? cb() : this.onEnd(), ms || this.initialMs);\n  }\n  clear() {\n    clearTimeout(this.timer);\n    this.timer = null;\n  }\n  end() {\n    this.clear();\n    this.onEnd();\n  }\n  isValid() {\n    return this.initialMs - (Date.now() - this.startTimestamp) > 0;\n  }\n}","import { Timer } from './timer';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nimport { debounce } from '../util/invoke';\nimport { isBrowserScope } from '../constants/runtime';\nexport class InteractionTimer extends Timer {\n  constructor(opts, ms) {\n    super(opts, ms);\n    this.onPause = typeof opts.onPause === 'function' ? opts.onPause : () => {/* noop */};\n    this.onRefresh = typeof opts.onRefresh === 'function' ? opts.onRefresh : () => {/* noop */};\n    this.onResume = typeof opts.onResume === 'function' ? opts.onResume : () => {/* noop */};\n\n    // used by pause/resume\n    this.remainingMs = undefined;\n    if (!opts.refreshEvents) opts.refreshEvents = ['click', 'keydown', 'scroll'];\n\n    // the abort controller is used to \"reset\" the event listeners and prevent them from duplicating when new sessions are created\n    try {\n      this.abortController = new AbortController();\n    } catch (e) {\n      // this try-catch can be removed when IE11 is completely unsupported & gone\n    }\n    if (isBrowserScope && opts.ee) {\n      if (opts.ee) {\n        this.ee = opts.ee;\n        const debouncedRefresh = debounce(this.refresh.bind(this), 500, {\n          leading: true\n        });\n        this.refreshHandler = evts => {\n          if (opts.refreshEvents.includes(evts?.[0]?.type)) {\n            debouncedRefresh();\n          }\n        };\n        opts.ee.on('fn-end', this.refreshHandler);\n      }\n\n      // watch for the vis state changing.  If the page is hidden, the local inactivity timer should be paused\n      // if the page is brought BACK to visibility and the timer hasnt \"naturally\" expired, refresh the timer...\n      // this is to support the concept that other tabs could be experiencing activity.  The thought would be that\n      // \"backgrounded\" tabs would pause, while \"closed\" tabs that \"reopen\" will just instantiate a new SessionEntity class if restored\n      // which will do a \"hard\" check of the timestamps.\n\n      // NOTE -- this does not account for 2 browser windows open side by side, blurring/focusing between them\n      // IF DEEMED necessary, more event handling would be needed to account for this.\n      subscribeToVisibilityChange(state => {\n        if (state === 'hidden') this.pause();\n        // vis change --> visible is treated like a new interaction with the page\n        else this.resume();\n      }, false, false, this.abortController?.signal);\n    }\n  }\n  abort() {\n    this.clear();\n    this.abortController?.abort();\n    if (this.refreshHandler) {\n      this.ee.removeEventListener('fn-end', this.refreshHandler);\n      this.refreshHandler = this.ee = null;\n    }\n  }\n  pause() {\n    this.onPause();\n    clearTimeout(this.timer);\n    this.remainingMs = this.initialMs - (Date.now() - this.startTimestamp);\n  }\n  resume() {\n    this.refresh();\n    this.onResume(); // emit resume event after state updated\n  }\n\n  refresh(cb, ms) {\n    this.clear();\n    this.timer = this.create(cb, ms);\n    this.startTimestamp = Date.now();\n    this.remainingMs = undefined;\n    this.onRefresh();\n  }\n}","import { generateRandomHexString } from '../ids/unique-id';\nimport { warn } from '../util/console';\nimport { stringify } from '../util/stringify';\nimport { ee } from '../event-emitter/contextual-ee';\nimport { Timer } from '../timer/timer';\nimport { isBrowserScope } from '../constants/runtime';\nimport { DEFAULT_EXPIRES_MS, DEFAULT_INACTIVE_MS, PREFIX } from './constants';\nimport { InteractionTimer } from '../timer/interaction-timer';\nimport { wrapEvents } from '../wrap';\nimport { getModeledObject } from '../config/state/configurable';\nimport { handle } from '../event-emitter/handle';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../features/metrics/constants';\nimport { FEATURE_NAMES } from '../../loaders/features/features';\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nexport const MODE = {\n  OFF: 0,\n  FULL: 1,\n  ERROR: 2\n};\n// this is what can be stored in local storage (not enforced but probably should be)\n// these values should sync between local storage and the parent class props\nconst model = {\n  value: '',\n  inactiveAt: 0,\n  expiresAt: 0,\n  updatedAt: Date.now(),\n  sessionReplayMode: MODE.OFF,\n  sessionReplaySentFirstChunk: false,\n  sessionTraceMode: MODE.OFF,\n  traceHarvestStarted: false,\n  custom: {}\n};\nexport const SESSION_EVENTS = {\n  PAUSE: 'session-pause',\n  RESET: 'session-reset',\n  RESUME: 'session-resume',\n  UPDATE: 'session-update'\n};\nexport const SESSION_EVENT_TYPES = {\n  SAME_TAB: 'same-tab',\n  CROSS_TAB: 'cross-tab'\n};\nexport class SessionEntity {\n  /**\n   * Create a self-managing Session Entity. This entity is scoped to the agent identifier which triggered it, allowing for multiple simultaneous session objects to exist.\n   * There is one \"namespace\" an agent can store data in LS -- NRBA_{key}. If there are two agents on one page, and they both use the same key, they could overwrite each other since they would both use the same namespace in LS by default.\n   * The value can be overridden in the constructor, but will default to a unique 16 character hex string\n   * expiresMs and inactiveMs are used to \"expire\" the session, but can be overridden in the constructor. Pass 0 to disable expiration timers.\n   */\n  constructor(opts) {\n    const {\n      agentIdentifier,\n      key,\n      storage\n    } = opts;\n    if (!agentIdentifier || !key || !storage) {\n      throw new Error(\"Missing required field(s):\".concat(!agentIdentifier ? ' agentID' : '').concat(!key ? ' key' : '').concat(!storage ? ' storage' : ''));\n    }\n    this.agentIdentifier = agentIdentifier;\n    this.storage = storage;\n    this.state = {};\n\n    // key is intended to act as the k=v pair\n    this.key = key;\n    this.ee = ee.get(agentIdentifier);\n    wrapEvents(this.ee);\n    this.setup(opts);\n    if (isBrowserScope) {\n      windowAddEventListener('storage', event => {\n        if (event.key === this.lookupKey) {\n          const obj = typeof event.newValue === 'string' ? JSON.parse(event.newValue) : event.newValue;\n          this.sync(obj);\n          this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.CROSS_TAB, this.state]);\n        }\n      });\n    }\n  }\n  setup(_ref) {\n    let {\n      value = generateRandomHexString(16),\n      expiresMs = DEFAULT_EXPIRES_MS,\n      inactiveMs = DEFAULT_INACTIVE_MS\n    } = _ref;\n    this.state = {};\n    this.sync(model);\n\n    // value is intended to act as the primary value of the k=v pair\n    this.state.value = value;\n    this.expiresMs = expiresMs;\n    this.inactiveMs = inactiveMs;\n\n    // the first time the session entity class is instantiated, we check the storage API for an existing\n    // object. If it exists, the values inside the object are used to inform the timers that run locally.\n    // if the initial read is empty, it allows us to set a \"fresh\" \"new\" session immediately.\n    // the local timers are used after the session is running to \"expire\" the session, allowing for pausing timers etc.\n    // the timestamps stored in the storage API can be checked at initial run, and when the page is restored, otherwise we lean\n    // on the local timers to expire the session\n    const initialRead = this.read();\n\n    // the set-up of the timer used to expire the session \"naturally\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    if (expiresMs) {\n      this.state.expiresAt = initialRead?.expiresAt || this.getFutureTimestamp(expiresMs);\n      this.expiresTimer = new Timer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('expired');\n          this.collectSM('duration');\n          this.reset();\n        }\n      }, this.state.expiresAt - Date.now());\n    } else {\n      this.state.expiresAt = Infinity;\n    }\n\n    // the set-up of the timer used to expire the session due to \"inactivity\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    // this gets \"refreshed\" when \"activity\" is observed\n    if (inactiveMs) {\n      this.state.inactiveAt = initialRead?.inactiveAt || this.getFutureTimestamp(inactiveMs);\n      this.inactiveTimer = new InteractionTimer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('inactive');\n          this.collectSM('duration');\n          this.reset();\n        },\n        // When the inactive timer refreshes, it will update the storage values with an update timestamp\n        onRefresh: this.refresh.bind(this),\n        onResume: () => {\n          this.ee.emit(SESSION_EVENTS.RESUME);\n        },\n        // When the inactive timer pauses, update the storage values with an update timestamp\n        onPause: () => {\n          if (this.initialized) this.ee.emit(SESSION_EVENTS.PAUSE);\n          this.write(getModeledObject(this.state, model));\n        },\n        ee: this.ee,\n        refreshEvents: ['click', 'keydown', 'scroll']\n      }, this.state.inactiveAt - Date.now());\n    } else {\n      this.state.inactiveAt = Infinity;\n    }\n\n    // The fact that the session is \"new\" or pre-existing is used in some places in the agent.  Session Replay and Trace\n    // can use this info to inform whether to trust a new sampling decision vs continue a previous tracking effort.\n    this.isNew = !Object.keys(initialRead).length;\n    // if its a \"new\" session, we write to storage API with the default values.  These values may change over the lifespan of the agent run.\n    // we can use a modeled object here to help us know and manage what values are being used. -- see \"model\" above\n    if (this.isNew) this.write(getModeledObject(this.state, model), true);else this.sync(initialRead);\n    this.initialized = true;\n  }\n\n  // This is the actual key appended to the storage API\n  get lookupKey() {\n    return \"\".concat(PREFIX, \"_\").concat(this.key);\n  }\n  sync(data) {\n    Object.assign(this.state, data);\n  }\n\n  /**\n   * Fetch the stored values from the storage API tied to this entity\n   * @returns {Object}\n   */\n  read() {\n    try {\n      const val = this.storage.get(this.lookupKey);\n      if (!val) return {};\n      // TODO - decompression would need to happen here if we decide to do it\n      const obj = typeof val === 'string' ? JSON.parse(val) : val;\n      if (this.isInvalid(obj)) return {};\n      // if the session expires, collect a SM count before resetting\n      if (this.isExpired(obj.expiresAt)) {\n        this.collectSM('expired');\n        this.collectSM('duration', obj, true);\n        return this.reset();\n      }\n      // if \"inactive\" timer is expired at \"read\" time -- esp. initial read -- reset\n      // collect a SM count before resetting\n      if (this.isExpired(obj.inactiveAt)) {\n        this.collectSM('inactive');\n        this.collectSM('duration', obj, true);\n        return this.reset();\n      }\n      return obj;\n    } catch (e) {\n      warn('Failed to read from storage API', e);\n      // storage is inaccessible\n      return {};\n    }\n  }\n\n  /**\n   * Store data to the storage API tied to this entity\n   * To preseve existing attributes, the output of ...session.read()\n   * should be appended to the data argument\n   * @param {Object} data\n   * @returns {Object}\n   */\n  write(data) {\n    try {\n      if (!data || typeof data !== 'object') return;\n      // everytime we update, we can update a timestamp for sanity\n      data.updatedAt = Date.now();\n      this.sync(data); // update the parent class \"state\" properties with the local storage values\n      //\n      // TODO - compression would need happen here if we decide to do it\n      this.storage.set(this.lookupKey, stringify(this.state));\n      this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.SAME_TAB, this.state]);\n      return data;\n    } catch (e) {\n      // storage is inaccessible\n      warn('Failed to write to the storage API', e);\n      return null;\n    }\n  }\n  reset() {\n    // this method should set off a chain of actions across the features by emitting 'new-session'\n    // * send off pending payloads\n    // * stop recording (stn and sr)...\n    // * delete the session and start over\n    try {\n      if (this.initialized) this.ee.emit(SESSION_EVENTS.RESET);\n      this.storage.remove(this.lookupKey);\n      this.inactiveTimer?.abort?.();\n      this.expiresTimer?.clear?.();\n      delete this.isNew;\n      this.setup({\n        agentIdentifier: this.agentIdentifier,\n        key: this.key,\n        storage: this.storage,\n        expiresMs: this.expiresMs,\n        inactiveMs: this.inactiveMs\n      });\n      return this.read();\n    } catch (e) {\n      return {};\n    }\n  }\n\n  /**\n   * Refresh the inactivity timer data\n   */\n  refresh() {\n    // read here & invalidate\n    const existingData = this.read();\n    this.write({\n      ...existingData,\n      inactiveAt: this.getFutureTimestamp(this.inactiveMs)\n    });\n  }\n\n  /**\n   * @param {number} timestamp\n   * @returns {boolean}\n   */\n  isExpired(timestamp) {\n    return Date.now() > timestamp;\n  }\n\n  /**\n   * @param {Object} data\n   * @returns {boolean}\n   */\n  isInvalid(data) {\n    const requiredKeys = Object.keys(model);\n    return !requiredKeys.every(x => Object.keys(data).includes(x));\n  }\n  collectSM(type, data, useUpdatedAt) {\n    let value, tag;\n    if (type === 'duration') {\n      value = this.getDuration(data, useUpdatedAt);\n      tag = 'Session/Duration/Ms';\n    }\n    if (type === 'expired') tag = 'Session/Expired/Seen';\n    if (type === 'inactive') tag = 'Session/Inactive/Seen';\n    if (tag) handle(SUPPORTABILITY_METRIC_CHANNEL, [tag, value], undefined, FEATURE_NAMES.metrics, this.ee);\n  }\n  getDuration() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n    let useUpdatedAt = arguments.length > 1 ? arguments[1] : undefined;\n    const startingTimestamp = data.expiresAt - this.expiresMs;\n    const endingTimestamp = !useUpdatedAt ? data.updatedAt : Date.now();\n    return endingTimestamp - startingTimestamp;\n  }\n\n  /**\n   * @param {number} futureMs - The number of ms to use to generate a future timestamp\n   * @returns {number}\n   */\n  getFutureTimestamp(futureMs) {\n    return Date.now() + futureMs;\n  }\n  syncCustomAttribute(key, value) {\n    if (!isBrowserScope) return;\n    if (value === null) {\n      const curr = this.read();\n      if (curr.custom) {\n        delete curr.custom[key];\n        this.write({\n          ...curr\n        });\n      }\n    } else {\n      const curr = this.read();\n      this.custom = {\n        ...(curr?.custom || {}),\n        [key]: value\n      };\n      this.write({\n        ...curr,\n        custom: this.custom\n      });\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/**\n * Reduce the invocation of the supplied function so that it is only invoked\n * once within a given timeout.\n *\n * If `wait` is `0`, the function will be invoked during the next tick.\n * If `options.leading` is false or not provided, the function will be invoked\n * N milliseconds after the last invocation of the returned function where\n * N is the `timeout` value.\n * If `options.leading` is true, the function will be invoked immediately upon\n * the first invocation of the returned function and not again for N milliseconds\n * where N is the `timeout` value.\n * @param {function} func Function whose invocation should be limited so it is only invoked\n * once within a given timeout period.\n * @param {number} timeout Time in milliseconds that the function should only be invoked\n * once within.\n * @param {object} options Debounce options\n * @param {boolean} options.leading Forces the function to be invoked on the first\n * invocation of the returned function instead of N milliseconds after the last\n * invocation.\n * @returns {function} A wrapping function that will ensure the provided function\n * is invoked only once within the given timeout.\n */\nexport function debounce(func) {\n  var _this = this;\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const leading = options?.leading || false;\n  let timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (leading && timer === undefined) {\n      func.apply(_this, args);\n      timer = setTimeout(() => {\n        timer = clearTimeout(timer);\n      }, timeout);\n    }\n    if (!leading) {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        func.apply(_this, args);\n      }, timeout);\n    }\n  };\n}\n\n/**\n * Reduce the invocation of the supplied function so that it is only invoked\n * once.\n * @param {function} func Function whose invocation should be limited so it is only invoked\n * once.\n * @returns {function} A wrapping function that will ensure the provided function\n * is invoked only once.\n */\nexport function single(func) {\n  var _this2 = this;\n  let called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      func.apply(_this2, args);\n    }\n  };\n}"],"names":["HarvestScheduler","SharedContext","constructor","endpoint","opts","parent","_this$sharedContext","super","this","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","ee","on","SESSION_EVENTS","RESET","runHarvest","forceNoRetry","onUnload","startTimer","interval","initialDelay","scheduleHarvest","stopTimer","permanently","arguments","length","undefined","clearTimeout","delay","setTimeout","cbRanAfterSend","result","retry","onHarvestFinished","submitMethod","payload","harvests","getPayload","submitData","isFinalHarvest","Object","prototype","toString","call","push","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","Timer","ms","onEnd","Error","initialMs","startTimestamp","Date","now","timer","create","cb","clear","end","isValid","InteractionTimer","onPause","onRefresh","onResume","remainingMs","refreshEvents","abortController","AbortController","e","isBrowserScope","_this$abortController","debouncedRefresh","debounce","refresh","leading","refreshHandler","evts","_evts$","includes","type","subscribeToVisibilityChange","state","pause","resume","signal","abort","_this$abortController2","removeEventListener","MODE","OFF","FULL","ERROR","model","value","inactiveAt","expiresAt","updatedAt","sessionReplayMode","sessionReplaySentFirstChunk","sessionTraceMode","traceHarvestStarted","custom","PAUSE","RESUME","UPDATE","SESSION_EVENT_TYPES","SAME_TAB","CROSS_TAB","SessionEntity","agentIdentifier","key","storage","concat","get","wrapEvents","setup","windowAddEventListener","event","lookupKey","obj","newValue","JSON","parse","sync","emit","_ref","generateRandomHexString","expiresMs","DEFAULT_EXPIRES_MS","inactiveMs","DEFAULT_INACTIVE_MS","initialRead","read","getFutureTimestamp","expiresTimer","collectSM","reset","Infinity","inactiveTimer","initialized","write","getModeledObject","isNew","keys","PREFIX","data","assign","val","isInvalid","isExpired","warn","set","stringify","_this$inactiveTimer","_this$inactiveTimer$a","_this$expiresTimer","_this$expiresTimer$cl","remove","existingData","timestamp","every","x","useUpdatedAt","tag","getDuration","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","metrics","startingTimestamp","futureMs","syncCustomAttribute","curr","isWorkerScope","globalScope","cleanupTasks","origClose","close","task","func","_this","timeout","options","_len","Array","_key","apply","single","_this2","called","_len2","_key2"],"sourceRoot":""}