{"version":3,"file":"static/js/session_trace-aggregate.e0a3068d.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorSet.js","../node_modules/@newrelic/browser-agent/dist/esm/features/utils/handler-cache.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/index.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/replay-mode.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}","/**\n * A class to defer callback execution until a decision can be reached\n */\nexport class HandlerCache {\n  /** @private @type {boolean | undefined} */\n  #decision = undefined;\n  /** @private @type {Function[]} */\n  #cache = [];\n  /** @private @type {Timeout} */\n  #settleTimer = setTimeout(() => this.#close(), 5000);\n  #noMoreChanges = false;\n\n  /**\n   * tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #drain() {\n    this.#cache.forEach(h => h());\n    this.#close();\n  }\n\n  /**\n   * tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #close() {\n    this.#cache = [];\n    clearTimeout(this.#settleTimer);\n  }\n\n  /**\n   * Wrap callback functions with this method to defer their execution until a decision has been reached\n   * @param {Function} handler\n   * @returns {void}\n   */\n  settle(handler) {\n    if (this.#decision === false) {\n      // Do nothing\n    } else if (this.#decision === undefined) this.#cache.push(handler);else handler();\n  }\n\n  /**\n   * Make a decision about what to do with the cache of callbacks.\n   * --- if true: tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache ---\n   * --- if false: tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @param {boolean} decision\n   */\n  decide(decision) {\n    if (this.#noMoreChanges) return;\n    this.#decision = decision;\n    if (decision === false) this.#close();\n    if (decision === true) this.#drain();\n  }\n  permanentlyDecide(decision) {\n    if (this.#noMoreChanges) return;\n    this.decide(decision);\n    this.#noMoreChanges = true;\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { now } from '../../../common/timing/now';\nimport { FEATURE_NAME } from '../constants';\nimport { HandlerCache } from '../../utils/handler-cache';\nimport { MODE, SESSION_EVENTS } from '../../../common/session/session-entity';\nimport { getSessionReplayMode } from '../../session_replay/replay-mode';\nimport { AggregateBase } from '../../utils/aggregate-base';\nconst ignoredEvents = {\n  // we find that certain events make the data too noisy to be useful\n  global: {\n    mouseup: true,\n    mousedown: true\n  },\n  // certain events are present both in the window and in PVT metrics.  PVT metrics are prefered so the window events should be ignored\n  window: {\n    load: true,\n    pagehide: true\n  },\n  // when ajax instrumentation is disabled, all XMLHttpRequest events will return with origin = xhrOriginMissing and should be ignored\n  xhrOriginMissing: {\n    ignoreAll: true\n  }\n};\nconst toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n};\nconst MAX_TRACE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst REQ_THRESHOLD_TO_SEND = 30;\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  #scheduler;\n  constructor(agentIdentifier, aggregator, argsObj) {\n    var _this;\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    _this = this;\n    this.agentRuntime = getRuntime(agentIdentifier);\n\n    // Very unlikely, but in case the existing XMLHttpRequest.prototype object on the page couldn't be wrapped.\n    if (!this.agentRuntime.xhrWrappable) return;\n    this.resourceObserver = argsObj?.resourceObserver; // undefined if observer couldn't be created\n    this.ptid = '';\n    this.trace = {};\n    this.nodeCount = 0;\n    this.sentTrace = null;\n    this.harvestTimeSeconds = getConfigurationValue(agentIdentifier, 'session_trace.harvestTimeSeconds') || 10;\n    this.maxNodesPerHarvest = getConfigurationValue(agentIdentifier, 'session_trace.maxNodesPerHarvest') || 1000;\n    /**\n     * Standalone (mode) refers to the legacy version of ST before the idea of 'session' or the Replay feature existed.\n     * It has some different behavior vs when used in tandem with replay. */\n    this.isStandalone = false;\n    const operationalGate = new HandlerCache(); // acts as a controller-intermediary that can enable or disable this feature's collection dynamically\n    const sessionEntity = this.agentRuntime.session;\n    this.operationalGate = operationalGate;\n\n    /* --- The following section deals with user sessions concept & contains non-trivial control flow. --- */\n    const controlTraceOp = traceMode => {\n      switch (traceMode) {\n        case MODE.ERROR:\n          this.startTracing(operationalGate, true);\n          break;\n        case MODE.FULL:\n        case true:\n          this.startTracing(operationalGate);\n          break;\n        case MODE.OFF:\n        case false:\n        default:\n          // this feature becomes \"off\" (does nothing & nothing is sent)\n          operationalGate.decide(false);\n          break;\n      }\n    };\n    let seenAnError = false;\n    let mostRecentModeKnown;\n    this.ee.on(SESSION_EVENTS.UPDATE, (eventType, sessionState) => {\n      // this will only have an effect if ST is NOT already in full mode\n      if (sessionState.sessionReplayMode === MODE.FULL) switchToFull();\n    });\n\n    /**\n     * The goal of switchToFull is to take external input to trigger a change from off or error to full.\n     * It will have no effect if already running in full mode.\n     * \"external\" input in this case means errors thrown on the page or session replay itself being triggered to run in full mode by the API, which updates the session entity.\n     */\n    const switchToFull = () => {\n      if (this.agentRuntime?.session?.state?.sessionReplayMode !== MODE.FULL) return;\n      if (mostRecentModeKnown !== MODE.FULL) {\n        const prevMode = mostRecentModeKnown;\n        mostRecentModeKnown = MODE.FULL;\n        sessionEntity.write({\n          sessionTraceMode: mostRecentModeKnown\n        });\n        this.isStandalone = false;\n        if (prevMode === MODE.ERROR && this.#scheduler) {\n          this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // up until now, Trace would've been just buffering nodes up to max, which needs to be trimmed to last X seconds\n          this.#scheduler.runHarvest({\n            needResponse: true\n          });\n        } else {\n          controlTraceOp(MODE.FULL);\n        }\n      }\n    };\n    if (!sessionEntity) {\n      // Since session manager isn't around, do the old Trace behavior of waiting for RUM response to decide feature activation.\n      this.isStandalone = true;\n      registerHandler('rumresp-stn', on => controlTraceOp(on), this.featureName, this.ee);\n    } else {\n      registerHandler('errorAgg', () => {\n        seenAnError = true;\n        switchToFull();\n      }, this.featureName, this.ee);\n      const stopTracePerm = () => {\n        if (sessionEntity.state.sessionTraceMode !== MODE.OFF) sessionEntity.write({\n          sessionTraceMode: MODE.OFF\n        });\n        operationalGate.permanentlyDecide(false);\n        if (mostRecentModeKnown === MODE.FULL) this.#scheduler?.runHarvest(); // allow queued nodes (past opGate) to final harvest, unless they were buffered in other modes\n        this.#scheduler?.stopTimer(true); // the 'true' arg here will forcibly block any future call to runHarvest, so the last runHarvest above must be prior\n        this.#scheduler = null;\n      };\n\n      // CAUTION: everything inside this promise runs post-load; event subscribers must be pre-load aka synchronous with constructor\n      this.waitForFlags(['stn', 'sr']).then(async _ref => {\n        let [traceOn, replayOn] = _ref;\n        if (!replayOn) {\n          // When sr = 0 from BCS, also do the old Trace behavior:\n          this.isStandalone = true;\n          controlTraceOp(traceOn);\n        } else {\n          this.ee.on('REPLAY_ABORTED', () => stopTracePerm());\n          /* Assuming on page visible that the trace mode is updated from shared session,\n           - if trace is turned off from the other page, it should be likewise here.\n           - if trace switches to Full mode, harvest should start (prev: Error) if not already running (prev: Full). */\n          this.ee.on(SESSION_EVENTS.RESUME, () => {\n            const updatedTraceMode = sessionEntity.state.sessionTraceMode;\n            if (updatedTraceMode === MODE.OFF) stopTracePerm();else if (updatedTraceMode === MODE.FULL && this.#scheduler && !this.#scheduler.started) this.#scheduler.runHarvest({\n              needResponse: true\n            });\n            mostRecentModeKnown = updatedTraceMode;\n          });\n          this.ee.on(SESSION_EVENTS.PAUSE, () => {\n            mostRecentModeKnown = sessionEntity.state.sessionTraceMode;\n          });\n          if (!sessionEntity.isNew) {\n            // inherit the same mode as existing session's Trace\n            if (sessionEntity.state.sessionReplayMode === MODE.OFF) this.isStandalone = true;\n            controlTraceOp(mostRecentModeKnown = sessionEntity.state.sessionTraceMode);\n          } else {\n            // for new sessions, see the truth table associated with NEWRELIC-8662 wrt the new Trace behavior under session management\n            const replayMode = await getSessionReplayMode(agentIdentifier);\n            if (replayMode === MODE.OFF) this.isStandalone = true; // without SR, Traces are still subject to old harvest limits\n\n            let startingMode;\n            if (traceOn === true) {\n              // CASE: both trace (entitlement+sampling) & replay (entitlement) flags are true from RUM\n              startingMode = MODE.FULL; // always full capture regardless of replay sampling decisions\n            } else {\n              // CASE: trace flag is off, BUT it must still run if replay is on (possibly)\n              // At this point, it's possible that 1 or more exception was thrown, in which case just start in full if Replay originally started in ERROR mode.\n              if (replayMode === MODE.ERROR && seenAnError) startingMode = MODE.FULL;else startingMode = replayMode;\n            }\n            sessionEntity.write({\n              sessionTraceMode: mostRecentModeKnown = startingMode\n            });\n            controlTraceOp(startingMode);\n          }\n        }\n      });\n    }\n    /* --- EoS --- */\n\n    // register the handlers immediately... but let the handlerCache decide if the data should actually get stored...\n    registerHandler('bst', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return operationalGate.settle(() => _this.storeEvent(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstResource', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return operationalGate.settle(() => _this.storeResources(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstHist', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return operationalGate.settle(() => _this.storeHist(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstXhrAgg', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return operationalGate.settle(() => _this.storeXhrAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstApi', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return operationalGate.settle(() => _this.storeSTN(...args));\n    }, this.featureName, this.ee);\n    registerHandler('errorAgg', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return operationalGate.settle(() => _this.storeErrorAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('pvtAdded', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return operationalGate.settle(() => _this.processPVT(...args));\n    }, this.featureName, this.ee);\n    this.drain();\n  }\n  startTracing(startupBuffer) {\n    let dontStartHarvestYet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof PerformanceNavigationTiming !== 'undefined') {\n      this.storeTiming(window.performance.getEntriesByType('navigation')[0]);\n    } else {\n      this.storeTiming(window.performance.timing);\n    }\n    this.#scheduler = new HarvestScheduler('resources', {\n      onFinished: this.#onHarvestFinished.bind(this),\n      retryDelay: this.harvestTimeSeconds\n    }, this);\n    this.#scheduler.harvest.on('resources', this.#prepareHarvest.bind(this));\n    if (dontStartHarvestYet === false) this.#scheduler.runHarvest({\n      needResponse: true\n    }); // sends first stn harvest immediately\n    startupBuffer.decide(true); // signal to ALLOW & process data in EE's buffer into internal nodes queued for next harvest\n  }\n\n  #onHarvestFinished(result) {\n    if (result.sent && result.responseText && !this.ptid) {\n      // continue interval harvest only if ptid was returned by server on the first\n      this.agentRuntime.ptid = this.ptid = result.responseText;\n      this.#scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    if (result.sent && result.retry && this.sentTrace) {\n      // merge previous trace back into buffer to retry for next harvest\n      Object.entries(this.sentTrace).forEach(_ref2 => {\n        let [name, listOfSTNodes] = _ref2;\n        if (this.nodeCount >= this.maxNodesPerHarvest) return;\n        this.nodeCount += listOfSTNodes.length;\n        this.trace[name] = this.trace[name] ? listOfSTNodes.concat(this.trace[name]) : listOfSTNodes;\n      });\n      this.sentTrace = null;\n    }\n  }\n  #prepareHarvest(options) {\n    if (this.isStandalone) {\n      if (this.ptid && now() >= MAX_TRACE_DURATION) {\n        // Perform a final harvest once we hit or exceed the max session trace time\n        options.isFinalHarvest = true;\n        this.operationalGate.permanentlyDecide(false);\n        this.#scheduler.stopTimer(true);\n      } else if (this.ptid && this.nodeCount <= REQ_THRESHOLD_TO_SEND && !options.isFinalHarvest) {\n        // Only harvest when more than some threshold of nodes are pending, after the very first harvest, with the exception of the last outgoing harvest.\n        return;\n      }\n    } else {\n      //   -- *cli May '26 - Update: Not rate limiting backgrounded pages either for now.\n      //   if (this.ptid && document.visibilityState === 'hidden' && this.nodeCount <= REQ_THRESHOLD_TO_SEND) return\n\n      const currentMode = this.agentRuntime.session.state.sessionTraceMode;\n      /* There could still be nodes previously collected even after Trace (w/ session mgmt) is turned off. Hence, continue to send the last batch.\n       * The intermediary controller SHOULD be already switched off so that no nodes are further queued. */\n      if (currentMode === MODE.OFF && Object.keys(this.trace).length === 0) return;\n      if (currentMode === MODE.ERROR) return; // Trace in this mode should never be harvesting, even on unload\n    }\n\n    return this.takeSTNs(options.retry);\n  }\n\n  // PageViewTiming (FEATURE) events and metrics, such as 'load', 'lcp', etc. pipes into ST here.\n  processPVT(name, value, attrs) {\n    this.storeTiming({\n      [name]: value\n    });\n    if (hasFID(name, attrs)) this.storeEvent({\n      type: 'fid',\n      target: 'document'\n    }, 'document', value, value + attrs.fid);\n    function hasFID(name, attrs) {\n      return name === 'fi' && !!attrs && typeof attrs.fid === 'number';\n    }\n  }\n\n  // This processes the aforementioned PVT and the first navigation entry of the page.\n  storeTiming(timingEntry) {\n    if (!timingEntry) return;\n\n    // loop iterates through prototype also (for FF)\n    for (let key in timingEntry) {\n      let val = timingEntry[key];\n\n      // ignore size and status type nodes that do not map to timestamp metrics\n      const lck = key.toLowerCase();\n      if (lck.indexOf('size') >= 0 || lck.indexOf('status') >= 0) continue;\n\n      // ignore inherited methods, meaningless 0 values, and bogus timestamps\n      // that are in the future (Microsoft Edge seems to sometimes produce these)\n      if (!(typeof val === 'number' && val >= 0)) continue;\n      val = Math.round(val);\n      this.storeSTN({\n        n: key,\n        s: val,\n        e: val,\n        o: 'document',\n        t: 'timing'\n      });\n    }\n  }\n\n  // Tracks the events and their listener's duration on objects wrapped by wrap-events.\n  storeEvent(currentEvent, target, start, end) {\n    if (this.shouldIgnoreEvent(currentEvent, target)) return;\n    const evt = {\n      n: this.evtName(currentEvent.type),\n      s: start,\n      e: end,\n      t: 'event'\n    };\n    try {\n      // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n      // it does not check currentEvent.currentTarget before calling getRootNode() on it\n      evt.o = this.evtOrigin(currentEvent.target, target);\n    } catch (e) {\n      evt.o = this.evtOrigin(null, target);\n    }\n    this.storeSTN(evt);\n  }\n  shouldIgnoreEvent(event, target) {\n    const origin = this.evtOrigin(event.target, target);\n    if (event.type in ignoredEvents.global) return true;\n    if (!!ignoredEvents[origin] && ignoredEvents[origin].ignoreAll) return true;\n    return !!(!!ignoredEvents[origin] && event.type in ignoredEvents[origin]);\n  }\n  evtName(type) {\n    switch (type) {\n      case 'keydown':\n      case 'keyup':\n      case 'keypress':\n        return 'typing';\n      case 'mousemove':\n      case 'mouseenter':\n      case 'mouseleave':\n      case 'mouseover':\n      case 'mouseout':\n        return 'mousing';\n      case 'scroll':\n        return 'scrolling';\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchend':\n      case 'touchcancel':\n      case 'touchenter':\n      case 'touchleave':\n        return 'touching';\n      default:\n        return type;\n    }\n  }\n  evtOrigin(t, target) {\n    let origin = 'unknown';\n    if (t && t instanceof XMLHttpRequest) {\n      const params = this.ee.context(t).params;\n      if (!params || !params.status || !params.method || !params.host || !params.pathname) return 'xhrOriginMissing';\n      origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname;\n    } else if (t && typeof t.tagName === 'string') {\n      origin = t.tagName.toLowerCase();\n      if (t.id) origin += '#' + t.id;\n      if (t.className) {\n        for (let i = 0; i < t.classList.length; i++) origin += '.' + t.classList[i];\n      }\n    }\n    if (origin === 'unknown') {\n      if (typeof target === 'string') origin = target;else if (target === document) origin = 'document';else if (target === window) origin = 'window';else if (target instanceof FileReader) origin = 'FileReader';\n    }\n    return origin;\n  }\n\n  // Tracks when the window history API specified by wrap-history is used.\n  storeHist(path, old, time) {\n    const node = {\n      n: 'history.pushState',\n      s: time,\n      e: time,\n      o: path,\n      t: old\n    };\n    this.storeSTN(node);\n  }\n  #laststart = 0;\n  // Processes all the PerformanceResourceTiming entries captured (by observer).\n  storeResources(resources) {\n    if (!resources || resources.length === 0) return;\n    resources.forEach(currentResource => {\n      if ((currentResource.fetchStart | 0) <= this.#laststart) return; // don't recollect already-seen resources\n\n      const parsed = parseUrl(currentResource.name);\n      const res = {\n        n: currentResource.initiatorType,\n        s: currentResource.fetchStart | 0,\n        e: currentResource.responseEnd | 0,\n        o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname,\n        // resource.name is actually a URL so it's the source\n        t: currentResource.entryType\n      };\n      this.storeSTN(res);\n    });\n    this.#laststart = resources[resources.length - 1].fetchStart | 0;\n  }\n\n  // JavascriptError (FEATURE) events pipes into ST here.\n  storeErrorAgg(type, name, params, metrics) {\n    if (type !== 'err') return; // internal errors are purposefully ignored\n    const node = {\n      n: 'error',\n      s: metrics.time,\n      e: metrics.time,\n      o: params.message,\n      t: params.stackHash\n    };\n    this.storeSTN(node);\n  }\n\n  // Ajax (FEATURE) events--XML & fetches--pipes into ST here.\n  storeXhrAgg(type, name, params, metrics) {\n    if (type !== 'xhr') return;\n    const node = {\n      n: 'Ajax',\n      s: metrics.time,\n      e: metrics.time + metrics.duration,\n      o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n      t: 'ajax'\n    };\n    this.storeSTN(node);\n  }\n\n  // Central function called by all the other store__ & addToTrace API to append a trace node.\n  storeSTN(stn) {\n    if (this.nodeCount >= this.maxNodesPerHarvest) {\n      // limit the amount of pending data awaiting next harvest\n      if (this.isStandalone || this.agentRuntime.session.state.sessionTraceMode !== MODE.ERROR) return;\n      const openedSpace = this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // but maybe we could make some space by discarding irrelevant nodes if we're in sessioned Error mode\n      if (openedSpace === 0) return;\n    }\n    if (this.isStandalone && now() >= MAX_TRACE_DURATION) {\n      return;\n    }\n    if (this.trace[stn.n]) this.trace[stn.n].push(stn);else this.trace[stn.n] = [stn];\n    this.nodeCount++;\n  }\n\n  /**\n   * Trim the collection of nodes awaiting harvest such that those seen outside a certain span of time are discarded.\n   * @param {number} lookbackDuration Past length of time until now for which we care about nodes, in milliseconds\n   * @returns {number} However many nodes were discarded after trimming.\n   */\n  trimSTNs(lookbackDuration) {\n    let prunedNodes = 0;\n    const cutoffHighResTime = Math.max(now() - lookbackDuration, 0);\n    Object.keys(this.trace).forEach(nameCategory => {\n      const nodeList = this.trace[nameCategory];\n      /* Notice nodes are appending under their name's list as they end and are stored. This means each list is already (roughly) sorted in chronological order by end time.\n       * This isn't exact since nodes go through some processing & EE handlers chain, but it's close enough as we still capture nodes whose duration overlaps the lookback window.\n       * ASSUMPTION: all 'end' timings stored are relative to timeOrigin (DOMHighResTimeStamp) and not Unix epoch based. */\n      let cutoffIdx = nodeList.findIndex(node => cutoffHighResTime <= node.e);\n      if (cutoffIdx === 0) return;else if (cutoffIdx < 0) {\n        // whole list falls outside lookback window and is irrelevant\n        cutoffIdx = nodeList.length;\n        delete this.trace[nameCategory];\n      } else nodeList.splice(0, cutoffIdx); // chop off everything outside our window i.e. before the last <lookbackDuration> timeframe\n\n      this.nodeCount -= cutoffIdx;\n      prunedNodes += cutoffIdx;\n    });\n    return prunedNodes;\n  }\n\n  // Used by session trace's harvester to create the payload body.\n  takeSTNs(retry) {\n    if (!this.resourceObserver) {\n      // if PO isn't supported, this checks resourcetiming buffer every harvest.\n      this.storeResources(window.performance.getEntriesByType('resource'));\n    }\n    let earliestTimeStamp = Infinity;\n    const stns = Object.entries(this.trace).flatMap(_ref3 => {\n      let [name, listOfSTNodes] = _ref3;\n      // basically take the \"this.trace\" map-obj and concat all the list-type values\n      const oldestNodeTS = listOfSTNodes.reduce((acc, next) => !acc || next.s < acc ? next.s : acc, undefined);\n      if (oldestNodeTS < earliestTimeStamp) earliestTimeStamp = oldestNodeTS;\n      if (!(name in toAggregate)) return listOfSTNodes;\n      // Special processing for event nodes dealing with user inputs:\n      const reindexByOriginFn = this.smearEvtsByOrigin(name);\n      const partitionListByOriginMap = listOfSTNodes.sort((a, b) => a.s - b.s).reduce(reindexByOriginFn, {});\n      return Object.values(partitionListByOriginMap).flat(); // join the partitions back into 1-D, now ordered by origin then start time\n    }, this);\n    if (stns.length === 0) return {};\n    if (retry) {\n      this.sentTrace = this.trace;\n    }\n    this.trace = {};\n    this.nodeCount = 0;\n    let firstHarvestOfSession;\n    if (this.agentRuntime.session) {\n      const isFirstPayload = !this.agentRuntime.session.state.traceHarvestStarted;\n      firstHarvestOfSession = {\n        fsh: Number(isFirstPayload)\n      }; // converted to '0' | '1'\n      if (isFirstPayload) this.agentRuntime.session.write({\n        traceHarvestStarted: true\n      });\n    }\n    return {\n      qs: {\n        st: this.agentRuntime.offset,\n        /** hr === \"hasReplay\" in NR1, standalone is always checked and processed before harvesting\n         * so a race condition between ST and SR states should not be a concern if implemented here */\n        hr: Number(!this.isStandalone),\n        /** fts === \"firstTimestamp\" in NR1, indicates what the earliest NODE timestamp was\n         * so that blob parsing doesn't need to happen to support UI/API functions  */\n        fts: this.agentRuntime.offset + earliestTimeStamp,\n        /** n === \"nodeCount\" in NR1, a count of nodes in the ST payload, so that blob parsing doesn't need to happen to support UI/API functions */\n        n: stns.length,\n        // node count\n        ...firstHarvestOfSession\n      },\n      body: {\n        res: stns\n      }\n    };\n  }\n  smearEvtsByOrigin(name) {\n    const maxGap = toAggregate[name][0];\n    const maxLen = toAggregate[name][1];\n    const lastO = {};\n    return (byOrigin, evtNode) => {\n      let lastArr = byOrigin[evtNode.o];\n      if (!lastArr) lastArr = byOrigin[evtNode.o] = [];\n      const last = lastO[evtNode.o];\n      if (name === 'scrolling' && !trivial(evtNode)) {\n        lastO[evtNode.o] = null;\n        evtNode.n = 'scroll';\n        lastArr.push(evtNode);\n      } else if (last && evtNode.s - last.s < maxLen && last.e > evtNode.s - maxGap) {\n        last.e = evtNode.e;\n      } else {\n        lastO[evtNode.o] = evtNode;\n        lastArr.push(evtNode);\n      }\n      return byOrigin;\n    };\n    function trivial(node) {\n      const limit = 4;\n      return !!(node && typeof node.e === 'number' && typeof node.s === 'number' && node.e - node.s < limit);\n    }\n  }\n}","import { getConfigurationValue } from '../../common/config/config';\nimport { MODE } from '../../common/session/session-entity';\nimport { gosNREUM } from '../../common/window/nreum';\nimport { sharedChannel } from '../../common/constants/shared-channel';\n\n/**\n * Figure out if the Replay feature is running (what mode it's in).\n * IMPORTANT: Session tracking is assumed to be ON; if applicable, check init's privacy.cookies_enabled setting before using this fn!\n * CRITICAL: This fn must be called prior to ALL features aggregate draining. If not, it will never resolve.\n * @param {String} agentId\n * @returns Promise that resolves to one of the values in MODE enum\n */\nexport async function getSessionReplayMode(agentId) {\n  try {\n    const newrelic = gosNREUM();\n    // Should be enabled by configuration and using an agent build that includes it (via checking that the instrument class was initialized).\n    if (getConfigurationValue(agentId, 'session_replay.enabled') && typeof newrelic.initializedAgents[agentId].features.session_replay === 'object') {\n      const srInitialized = await newrelic.initializedAgents[agentId].features.session_replay.onAggregateImported;\n      if (srInitialized) return await sharedChannel.sessionReplayInitialized; // wait for replay to determine which mode it's after running its sampling logic\n    }\n  } catch (e) {/* exception ==> off */}\n  return MODE.OFF; // at any step of the way s.t. SR cannot be on by implication or is explicitly off\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","_classPrivateFieldSet","receiver","privateMap","value","descriptor","set","call","writable","TypeError","classExtractFieldDescriptor","HandlerCache","constructor","_classPrivateMethodInitSpec","_close","_drain","_classPrivateFieldInitSpec","_decision","undefined","_cache","_settleTimer","setTimeout","_classPrivateMethodGet","this","_close2","_noMoreChanges","settle","handler","_classPrivateFieldGet","push","decide","decision","_drain2","permanentlyDecide","forEach","h","clearTimeout","ignoredEvents","global","mouseup","mousedown","window","load","pagehide","xhrOriginMissing","ignoreAll","toAggregate","typing","scrolling","mousing","touching","MAX_TRACE_DURATION","_scheduler","WeakMap","_onHarvestFinished","WeakSet","_prepareHarvest","_laststart","Aggregate","AggregateBase","agentIdentifier","aggregator","argsObj","_this","super","FEATURE_NAME","agentRuntime","getRuntime","xhrWrappable","resourceObserver","ptid","trace","nodeCount","sentTrace","harvestTimeSeconds","getConfigurationValue","maxNodesPerHarvest","isStandalone","operationalGate","sessionEntity","session","controlTraceOp","traceMode","MODE","ERROR","startTracing","FULL","OFF","mostRecentModeKnown","seenAnError","ee","on","SESSION_EVENTS","UPDATE","eventType","sessionState","sessionReplayMode","switchToFull","_this$agentRuntime","state","prevMode","write","sessionTraceMode","trimSTNs","runHarvest","needResponse","registerHandler","featureName","stopTracePerm","_classPrivateFieldGet2","_classPrivateFieldGet3","stopTimer","waitForFlags","then","async","traceOn","replayOn","_ref","RESUME","updatedTraceMode","started","PAUSE","isNew","replayMode","agentId","newrelic","gosNREUM","initializedAgents","features","session_replay","onAggregateImported","e","getSessionReplayMode","startingMode","_len","arguments","length","args","Array","_key","storeEvent","_len2","_key2","storeResources","_len3","_key3","storeHist","_len4","_key4","storeXhrAgg","_len5","_key5","storeSTN","_len6","_key6","storeErrorAgg","_len7","_key7","processPVT","drain","startupBuffer","dontStartHarvestYet","PerformanceNavigationTiming","storeTiming","performance","getEntriesByType","timing","HarvestScheduler","onFinished","_onHarvestFinished2","bind","retryDelay","harvest","_prepareHarvest2","name","attrs","fid","hasFID","type","target","timingEntry","key","val","lck","toLowerCase","indexOf","Math","round","n","s","o","t","currentEvent","start","end","shouldIgnoreEvent","evt","evtName","evtOrigin","event","origin","XMLHttpRequest","params","context","status","method","host","pathname","tagName","id","className","i","classList","document","FileReader","path","old","time","node","resources","currentResource","fetchStart","parsed","parseUrl","res","initiatorType","responseEnd","protocol","hostname","port","entryType","metrics","message","stackHash","duration","stn","now","lookbackDuration","prunedNodes","cutoffHighResTime","max","keys","nameCategory","nodeList","cutoffIdx","findIndex","splice","takeSTNs","retry","earliestTimeStamp","Infinity","stns","entries","flatMap","_ref3","listOfSTNodes","oldestNodeTS","reduce","acc","next","reindexByOriginFn","smearEvtsByOrigin","partitionListByOriginMap","sort","a","b","values","flat","firstHarvestOfSession","isFirstPayload","traceHarvestStarted","fsh","Number","qs","st","offset","hr","fts","body","maxGap","maxLen","lastO","byOrigin","evtNode","lastArr","last","limit","trivial","result","sent","responseText","startTimer","_ref2","concat","options","isFinalHarvest","currentMode","_defineProperty"],"sourceRoot":""}