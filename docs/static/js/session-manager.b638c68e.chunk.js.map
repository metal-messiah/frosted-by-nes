{"version":3,"file":"static/js/session-manager.b638c68e.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/timer/timer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/timer/interaction-timer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/session/session-entity.js","../node_modules/@newrelic/browser-agent/dist/esm/common/util/invoke.js","../node_modules/@newrelic/browser-agent/dist/esm/common/storage/local-storage.js","../node_modules/@newrelic/browser-agent/dist/esm/common/storage/first-party-cookies.js","../node_modules/@newrelic/browser-agent/dist/esm/features/utils/agent-session.js"],"sourcesContent":["export class Timer {\n  constructor(opts, ms) {\n    if (!opts.onEnd) throw new Error('onEnd handler is required');\n    if (!ms) throw new Error('ms duration is required');\n    this.onEnd = opts.onEnd;\n    this.initialMs = ms;\n    this.startTimestamp = Date.now();\n    this.timer = this.create(this.onEnd, ms);\n  }\n  create(cb, ms) {\n    if (this.timer) this.clear();\n    return setTimeout(() => cb ? cb() : this.onEnd(), ms || this.initialMs);\n  }\n  clear() {\n    clearTimeout(this.timer);\n    this.timer = null;\n  }\n  end() {\n    this.clear();\n    this.onEnd();\n  }\n  isValid() {\n    return this.initialMs - (Date.now() - this.startTimestamp) > 0;\n  }\n}","import { Timer } from './timer';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nimport { debounce } from '../util/invoke';\nimport { isBrowserScope } from '../constants/runtime';\nexport class InteractionTimer extends Timer {\n  constructor(opts, ms) {\n    super(opts, ms);\n    this.onPause = typeof opts.onPause === 'function' ? opts.onPause : () => {/* noop */};\n    this.onRefresh = typeof opts.onRefresh === 'function' ? opts.onRefresh : () => {/* noop */};\n    this.onResume = typeof opts.onResume === 'function' ? opts.onResume : () => {/* noop */};\n\n    // used by pause/resume\n    this.remainingMs = undefined;\n    if (!opts.refreshEvents) opts.refreshEvents = ['click', 'keydown', 'scroll'];\n\n    // the abort controller is used to \"reset\" the event listeners and prevent them from duplicating when new sessions are created\n    try {\n      this.abortController = new AbortController();\n    } catch (e) {\n      // this try-catch can be removed when IE11 is completely unsupported & gone\n    }\n    if (isBrowserScope && opts.ee) {\n      if (opts.ee) {\n        this.ee = opts.ee;\n        const debouncedRefresh = debounce(this.refresh.bind(this), 500, {\n          leading: true\n        });\n        this.refreshHandler = evts => {\n          if (opts.refreshEvents.includes(evts?.[0]?.type)) {\n            debouncedRefresh();\n          }\n        };\n        opts.ee.on('fn-end', this.refreshHandler);\n      }\n\n      // watch for the vis state changing.  If the page is hidden, the local inactivity timer should be paused\n      // if the page is brought BACK to visibility and the timer hasnt \"naturally\" expired, refresh the timer...\n      // this is to support the concept that other tabs could be experiencing activity.  The thought would be that\n      // \"backgrounded\" tabs would pause, while \"closed\" tabs that \"reopen\" will just instantiate a new SessionEntity class if restored\n      // which will do a \"hard\" check of the timestamps.\n\n      // NOTE -- this does not account for 2 browser windows open side by side, blurring/focusing between them\n      // IF DEEMED necessary, more event handling would be needed to account for this.\n      subscribeToVisibilityChange(state => {\n        if (state === 'hidden') this.pause();\n        // vis change --> visible is treated like a new interaction with the page\n        else this.resume();\n      }, false, false, this.abortController?.signal);\n    }\n  }\n  abort() {\n    this.clear();\n    this.abortController?.abort();\n    if (this.refreshHandler) {\n      this.ee.removeEventListener('fn-end', this.refreshHandler);\n      this.refreshHandler = this.ee = null;\n    }\n  }\n  pause() {\n    this.onPause();\n    clearTimeout(this.timer);\n    this.remainingMs = this.initialMs - (Date.now() - this.startTimestamp);\n  }\n  resume() {\n    this.refresh();\n    this.onResume(); // emit resume event after state updated\n  }\n\n  refresh(cb, ms) {\n    this.clear();\n    this.timer = this.create(cb, ms);\n    this.startTimestamp = Date.now();\n    this.remainingMs = undefined;\n    this.onRefresh();\n  }\n}","import { generateRandomHexString } from '../ids/unique-id';\nimport { warn } from '../util/console';\nimport { stringify } from '../util/stringify';\nimport { ee } from '../event-emitter/contextual-ee';\nimport { Timer } from '../timer/timer';\nimport { isBrowserScope } from '../constants/runtime';\nimport { DEFAULT_EXPIRES_MS, DEFAULT_INACTIVE_MS, PREFIX } from './constants';\nimport { InteractionTimer } from '../timer/interaction-timer';\nimport { wrapEvents } from '../wrap';\nimport { getModeledObject } from '../config/state/configurable';\nimport { handle } from '../event-emitter/handle';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../features/metrics/constants';\nimport { FEATURE_NAMES } from '../../loaders/features/features';\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nexport const MODE = {\n  OFF: 0,\n  FULL: 1,\n  ERROR: 2\n};\n// this is what can be stored in local storage (not enforced but probably should be)\n// these values should sync between local storage and the parent class props\nconst model = {\n  value: '',\n  inactiveAt: 0,\n  expiresAt: 0,\n  updatedAt: Date.now(),\n  sessionReplayMode: MODE.OFF,\n  sessionReplaySentFirstChunk: false,\n  sessionTraceMode: MODE.OFF,\n  traceHarvestStarted: false,\n  custom: {}\n};\nexport const SESSION_EVENTS = {\n  PAUSE: 'session-pause',\n  RESET: 'session-reset',\n  RESUME: 'session-resume',\n  UPDATE: 'session-update'\n};\nexport const SESSION_EVENT_TYPES = {\n  SAME_TAB: 'same-tab',\n  CROSS_TAB: 'cross-tab'\n};\nexport class SessionEntity {\n  /**\n   * Create a self-managing Session Entity. This entity is scoped to the agent identifier which triggered it, allowing for multiple simultaneous session objects to exist.\n   * There is one \"namespace\" an agent can store data in LS -- NRBA_{key}. If there are two agents on one page, and they both use the same key, they could overwrite each other since they would both use the same namespace in LS by default.\n   * The value can be overridden in the constructor, but will default to a unique 16 character hex string\n   * expiresMs and inactiveMs are used to \"expire\" the session, but can be overridden in the constructor. Pass 0 to disable expiration timers.\n   */\n  constructor(opts) {\n    const {\n      agentIdentifier,\n      key,\n      storage\n    } = opts;\n    if (!agentIdentifier || !key || !storage) {\n      throw new Error(\"Missing required field(s):\".concat(!agentIdentifier ? ' agentID' : '').concat(!key ? ' key' : '').concat(!storage ? ' storage' : ''));\n    }\n    this.agentIdentifier = agentIdentifier;\n    this.storage = storage;\n    this.state = {};\n\n    // key is intended to act as the k=v pair\n    this.key = key;\n    this.ee = ee.get(agentIdentifier);\n    wrapEvents(this.ee);\n    this.setup(opts);\n    if (isBrowserScope) {\n      windowAddEventListener('storage', event => {\n        if (event.key === this.lookupKey) {\n          const obj = typeof event.newValue === 'string' ? JSON.parse(event.newValue) : event.newValue;\n          this.sync(obj);\n          this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.CROSS_TAB, this.state]);\n        }\n      });\n    }\n  }\n  setup(_ref) {\n    let {\n      value = generateRandomHexString(16),\n      expiresMs = DEFAULT_EXPIRES_MS,\n      inactiveMs = DEFAULT_INACTIVE_MS\n    } = _ref;\n    this.state = {};\n    this.sync(model);\n\n    // value is intended to act as the primary value of the k=v pair\n    this.state.value = value;\n    this.expiresMs = expiresMs;\n    this.inactiveMs = inactiveMs;\n\n    // the first time the session entity class is instantiated, we check the storage API for an existing\n    // object. If it exists, the values inside the object are used to inform the timers that run locally.\n    // if the initial read is empty, it allows us to set a \"fresh\" \"new\" session immediately.\n    // the local timers are used after the session is running to \"expire\" the session, allowing for pausing timers etc.\n    // the timestamps stored in the storage API can be checked at initial run, and when the page is restored, otherwise we lean\n    // on the local timers to expire the session\n    const initialRead = this.read();\n\n    // the set-up of the timer used to expire the session \"naturally\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    if (expiresMs) {\n      this.state.expiresAt = initialRead?.expiresAt || this.getFutureTimestamp(expiresMs);\n      this.expiresTimer = new Timer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('expired');\n          this.collectSM('duration');\n          this.reset();\n        }\n      }, this.state.expiresAt - Date.now());\n    } else {\n      this.state.expiresAt = Infinity;\n    }\n\n    // the set-up of the timer used to expire the session due to \"inactivity\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    // this gets \"refreshed\" when \"activity\" is observed\n    if (inactiveMs) {\n      this.state.inactiveAt = initialRead?.inactiveAt || this.getFutureTimestamp(inactiveMs);\n      this.inactiveTimer = new InteractionTimer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('inactive');\n          this.collectSM('duration');\n          this.reset();\n        },\n        // When the inactive timer refreshes, it will update the storage values with an update timestamp\n        onRefresh: this.refresh.bind(this),\n        onResume: () => {\n          this.ee.emit(SESSION_EVENTS.RESUME);\n        },\n        // When the inactive timer pauses, update the storage values with an update timestamp\n        onPause: () => {\n          if (this.initialized) this.ee.emit(SESSION_EVENTS.PAUSE);\n          this.write(getModeledObject(this.state, model));\n        },\n        ee: this.ee,\n        refreshEvents: ['click', 'keydown', 'scroll']\n      }, this.state.inactiveAt - Date.now());\n    } else {\n      this.state.inactiveAt = Infinity;\n    }\n\n    // The fact that the session is \"new\" or pre-existing is used in some places in the agent.  Session Replay and Trace\n    // can use this info to inform whether to trust a new sampling decision vs continue a previous tracking effort.\n    this.isNew = !Object.keys(initialRead).length;\n    // if its a \"new\" session, we write to storage API with the default values.  These values may change over the lifespan of the agent run.\n    // we can use a modeled object here to help us know and manage what values are being used. -- see \"model\" above\n    if (this.isNew) this.write(getModeledObject(this.state, model), true);else this.sync(initialRead);\n    this.initialized = true;\n  }\n\n  // This is the actual key appended to the storage API\n  get lookupKey() {\n    return \"\".concat(PREFIX, \"_\").concat(this.key);\n  }\n  sync(data) {\n    Object.assign(this.state, data);\n  }\n\n  /**\n   * Fetch the stored values from the storage API tied to this entity\n   * @returns {Object}\n   */\n  read() {\n    try {\n      const val = this.storage.get(this.lookupKey);\n      if (!val) return {};\n      // TODO - decompression would need to happen here if we decide to do it\n      const obj = typeof val === 'string' ? JSON.parse(val) : val;\n      if (this.isInvalid(obj)) return {};\n      // if the session expires, collect a SM count before resetting\n      if (this.isExpired(obj.expiresAt)) {\n        this.collectSM('expired');\n        this.collectSM('duration', obj, true);\n        return this.reset();\n      }\n      // if \"inactive\" timer is expired at \"read\" time -- esp. initial read -- reset\n      // collect a SM count before resetting\n      if (this.isExpired(obj.inactiveAt)) {\n        this.collectSM('inactive');\n        this.collectSM('duration', obj, true);\n        return this.reset();\n      }\n      return obj;\n    } catch (e) {\n      warn('Failed to read from storage API', e);\n      // storage is inaccessible\n      return {};\n    }\n  }\n\n  /**\n   * Store data to the storage API tied to this entity\n   * To preseve existing attributes, the output of ...session.read()\n   * should be appended to the data argument\n   * @param {Object} data\n   * @returns {Object}\n   */\n  write(data) {\n    try {\n      if (!data || typeof data !== 'object') return;\n      // everytime we update, we can update a timestamp for sanity\n      data.updatedAt = Date.now();\n      this.sync(data); // update the parent class \"state\" properties with the local storage values\n      //\n      // TODO - compression would need happen here if we decide to do it\n      this.storage.set(this.lookupKey, stringify(this.state));\n      this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.SAME_TAB, this.state]);\n      return data;\n    } catch (e) {\n      // storage is inaccessible\n      warn('Failed to write to the storage API', e);\n      return null;\n    }\n  }\n  reset() {\n    // this method should set off a chain of actions across the features by emitting 'new-session'\n    // * send off pending payloads\n    // * stop recording (stn and sr)...\n    // * delete the session and start over\n    try {\n      if (this.initialized) this.ee.emit(SESSION_EVENTS.RESET);\n      this.storage.remove(this.lookupKey);\n      this.inactiveTimer?.abort?.();\n      this.expiresTimer?.clear?.();\n      delete this.isNew;\n      this.setup({\n        agentIdentifier: this.agentIdentifier,\n        key: this.key,\n        storage: this.storage,\n        expiresMs: this.expiresMs,\n        inactiveMs: this.inactiveMs\n      });\n      return this.read();\n    } catch (e) {\n      return {};\n    }\n  }\n\n  /**\n   * Refresh the inactivity timer data\n   */\n  refresh() {\n    // read here & invalidate\n    const existingData = this.read();\n    this.write({\n      ...existingData,\n      inactiveAt: this.getFutureTimestamp(this.inactiveMs)\n    });\n  }\n\n  /**\n   * @param {number} timestamp\n   * @returns {boolean}\n   */\n  isExpired(timestamp) {\n    return Date.now() > timestamp;\n  }\n\n  /**\n   * @param {Object} data\n   * @returns {boolean}\n   */\n  isInvalid(data) {\n    const requiredKeys = Object.keys(model);\n    return !requiredKeys.every(x => Object.keys(data).includes(x));\n  }\n  collectSM(type, data, useUpdatedAt) {\n    let value, tag;\n    if (type === 'duration') {\n      value = this.getDuration(data, useUpdatedAt);\n      tag = 'Session/Duration/Ms';\n    }\n    if (type === 'expired') tag = 'Session/Expired/Seen';\n    if (type === 'inactive') tag = 'Session/Inactive/Seen';\n    if (tag) handle(SUPPORTABILITY_METRIC_CHANNEL, [tag, value], undefined, FEATURE_NAMES.metrics, this.ee);\n  }\n  getDuration() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n    let useUpdatedAt = arguments.length > 1 ? arguments[1] : undefined;\n    const startingTimestamp = data.expiresAt - this.expiresMs;\n    const endingTimestamp = !useUpdatedAt ? data.updatedAt : Date.now();\n    return endingTimestamp - startingTimestamp;\n  }\n\n  /**\n   * @param {number} futureMs - The number of ms to use to generate a future timestamp\n   * @returns {number}\n   */\n  getFutureTimestamp(futureMs) {\n    return Date.now() + futureMs;\n  }\n  syncCustomAttribute(key, value) {\n    if (!isBrowserScope) return;\n    if (value === null) {\n      const curr = this.read();\n      if (curr.custom) {\n        delete curr.custom[key];\n        this.write({\n          ...curr\n        });\n      }\n    } else {\n      const curr = this.read();\n      this.custom = {\n        ...(curr?.custom || {}),\n        [key]: value\n      };\n      this.write({\n        ...curr,\n        custom: this.custom\n      });\n    }\n  }\n}","/**\n * Reduce the invocation of the supplied function so that it is only invoked\n * once within a given timeout.\n *\n * If `wait` is `0`, the function will be invoked during the next tick.\n * If `options.leading` is false or not provided, the function will be invoked\n * N milliseconds after the last invocation of the returned function where\n * N is the `timeout` value.\n * If `options.leading` is true, the function will be invoked immediately upon\n * the first invocation of the returned function and not again for N milliseconds\n * where N is the `timeout` value.\n * @param {function} func Function whose invocation should be limited so it is only invoked\n * once within a given timeout period.\n * @param {number} timeout Time in milliseconds that the function should only be invoked\n * once within.\n * @param {object} options Debounce options\n * @param {boolean} options.leading Forces the function to be invoked on the first\n * invocation of the returned function instead of N milliseconds after the last\n * invocation.\n * @returns {function} A wrapping function that will ensure the provided function\n * is invoked only once within the given timeout.\n */\nexport function debounce(func) {\n  var _this = this;\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const leading = options?.leading || false;\n  let timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (leading && timer === undefined) {\n      func.apply(_this, args);\n      timer = setTimeout(() => {\n        timer = clearTimeout(timer);\n      }, timeout);\n    }\n    if (!leading) {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        func.apply(_this, args);\n      }, timeout);\n    }\n  };\n}\n\n/**\n * Reduce the invocation of the supplied function so that it is only invoked\n * once.\n * @param {function} func Function whose invocation should be limited so it is only invoked\n * once.\n * @returns {function} A wrapping function that will ensure the provided function\n * is invoked only once.\n */\nexport function single(func) {\n  var _this2 = this;\n  let called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      func.apply(_this2, args);\n    }\n  };\n}","export class LocalStorage {\n  get(key) {\n    try {\n      // localStorage strangely type-casts non-existing data to \"null\"...\n      // Cast it back to undefined if it doesnt exist\n      return localStorage.getItem(key) || undefined;\n    } catch (err) {\n      // Error is ignored\n      return '';\n    }\n  }\n  set(key, value) {\n    try {\n      if (value === undefined || value === null) return this.remove(key);\n      return localStorage.setItem(key, value);\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n  remove(key) {\n    try {\n      localStorage.removeItem(key);\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n}","export class FirstPartyCookies {\n  constructor(domain) {\n    this.domain = domain;\n  }\n  get(name) {\n    try {\n      var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));\n      if (match) return match[2];\n    } catch (err) {\n      // Error is ignored\n      return '';\n    }\n  }\n  set(key, value) {\n    try {\n      const cookie = \"\".concat(key, \"=\").concat(value, \"; Domain=\").concat(this.domain, \"; Path=/\");\n      document.cookie = cookie;\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n  remove(key) {\n    try {\n      document.cookie = \"\".concat(key, \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Domain=\").concat(this.domain, \"; Path=/\");\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n}","import { getConfiguration, getInfo, getRuntime } from '../../common/config/config';\nimport { drain } from '../../common/drain/drain';\nimport { ee } from '../../common/event-emitter/contextual-ee';\nimport { registerHandler } from '../../common/event-emitter/register-handler';\nimport { SessionEntity } from '../../common/session/session-entity';\nimport { LocalStorage } from '../../common/storage/local-storage.js';\nimport { FirstPartyCookies } from '../../common/storage/first-party-cookies';\nlet ranOnce = 0;\nexport function setupAgentSession(agentIdentifier) {\n  const agentRuntime = getRuntime(agentIdentifier);\n  if (ranOnce++) return agentRuntime.session;\n  const sessionInit = getConfiguration(agentIdentifier).session;\n  /* Domain is a string that can be specified by customer. The only way to keep the session object across subdomains is using first party cookies.\n    This determines which storage wrapper the session manager will use to keep state. */\n  const storageTypeInst = sessionInit?.domain ? new FirstPartyCookies(sessionInit.domain) : new LocalStorage();\n  agentRuntime.session = new SessionEntity({\n    agentIdentifier,\n    key: 'SESSION',\n    storage: storageTypeInst,\n    expiresMs: sessionInit?.expiresMs,\n    inactiveMs: sessionInit?.inactiveMs\n  });\n\n  // Retrieve & re-add all of the persisted setCustomAttribute|setUserId k-v from previous page load(s), if any was stored.\n  const customSessionData = agentRuntime.session.state.custom;\n  const agentInfo = getInfo(agentIdentifier);\n  if (customSessionData) {\n    agentInfo.jsAttributes = {\n      ...agentInfo.jsAttributes,\n      ...customSessionData\n    };\n  }\n  const sharedEE = ee.get(agentIdentifier);\n\n  // any calls to newrelic.setCustomAttribute(<persisted>) will need to be added to:\n  // local info.jsAttributes {}\n  // the session's storage API\n  registerHandler('api-setCustomAttribute', (time, key, value) => {\n    agentRuntime.session.syncCustomAttribute(key, value);\n  }, 'session', sharedEE);\n\n  // any calls to newrelic.setUserId(...) will need to be added to:\n  // local info.jsAttributes {}\n  // the session's storage API\n  registerHandler('api-setUserId', (time, key, value) => {\n    agentRuntime.session.syncCustomAttribute(key, value);\n  }, 'session', sharedEE);\n  drain(agentIdentifier, 'session');\n  return agentRuntime.session;\n}"],"names":["Timer","constructor","opts","ms","onEnd","Error","this","initialMs","startTimestamp","Date","now","timer","create","cb","clear","setTimeout","clearTimeout","end","isValid","InteractionTimer","super","onPause","onRefresh","onResume","remainingMs","undefined","refreshEvents","abortController","AbortController","e","isBrowserScope","ee","_this$abortController","debouncedRefresh","debounce","refresh","bind","leading","refreshHandler","evts","_evts$","includes","type","on","subscribeToVisibilityChange","state","pause","resume","signal","abort","_this$abortController2","removeEventListener","MODE","OFF","FULL","ERROR","model","value","inactiveAt","expiresAt","updatedAt","sessionReplayMode","sessionReplaySentFirstChunk","sessionTraceMode","traceHarvestStarted","custom","SESSION_EVENTS","PAUSE","RESET","RESUME","UPDATE","SESSION_EVENT_TYPES","SAME_TAB","CROSS_TAB","SessionEntity","agentIdentifier","key","storage","concat","get","wrapEvents","setup","windowAddEventListener","event","lookupKey","obj","newValue","JSON","parse","sync","emit","_ref","generateRandomHexString","expiresMs","DEFAULT_EXPIRES_MS","inactiveMs","DEFAULT_INACTIVE_MS","initialRead","read","getFutureTimestamp","expiresTimer","collectSM","reset","Infinity","inactiveTimer","initialized","write","getModeledObject","isNew","Object","keys","length","PREFIX","data","assign","val","isInvalid","isExpired","warn","set","stringify","_this$inactiveTimer","_this$inactiveTimer$a","_this$expiresTimer","_this$expiresTimer$cl","remove","call","existingData","timestamp","every","x","useUpdatedAt","tag","getDuration","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","metrics","arguments","startingTimestamp","futureMs","syncCustomAttribute","curr","func","_this","timeout","options","_len","args","Array","_key","apply","single","_this2","called","_len2","_key2","LocalStorage","localStorage","getItem","err","setItem","removeItem","FirstPartyCookies","domain","name","match","document","cookie","RegExp","ranOnce","setupAgentSession","agentRuntime","getRuntime","session","sessionInit","getConfiguration","storageTypeInst","customSessionData","agentInfo","getInfo","jsAttributes","sharedEE","registerHandler","time","drain"],"sourceRoot":""}